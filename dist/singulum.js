/*!
 * Library: singulum
 * Description: State management sanity with minimal effort
 * Author: planttheidea
 * Version: 0.7.0
 * License: MIT
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("singulum", [], factory);
	else if(typeof exports === 'object')
		exports["singulum"] = factory();
	else
		root["singulum"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Singulum = __webpack_require__(2);\n\nvar _Singulum2 = _interopRequireDefault(_Singulum);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = new _Singulum2.default();\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvaW5kZXguanM/MWZkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU2luZ3VsdW0gZnJvbSAnLi9TaW5ndWx1bSc7XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBTaW5ndWx1bSgpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHNyYy9pbmRleC5qc1xuICoqLyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRUE7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(3);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar OBJECT_FREEZE = Object.freeze;\n\n/**\n * This is a basic counter in case a namespace is not provided when creating\n * a branch\n */\nvar namespaceIncrementer = 0;\n\n/**\n *\n * @param {Singulum} singulum\n */\nvar fireWatchers = function fireWatchers(singulum) {\n  singulum.$$watchers.forEach(function (watcher) {\n    watcher(singulum.store);\n  });\n};\n\n/**\n * Assigns new result to store, fires listener with new SingulumStore, and returns\n * Promise with new result\n *\n * @param {Singulum} singulum\n * @param {string} key\n * @param {*} result\n * @returns {Promise}\n */\nvar updateStoreValue = function updateStoreValue(singulum, result, key) {\n  /**\n   * Apply new result value to the store, scoped if the key is provided\n   */\n  if (key) {\n    singulum.$$store[key] = result;\n  } else {\n    singulum.$$store = result;\n  }\n\n  /**\n   * If there is a watcher, fire it\n   */\n  fireWatchers(singulum);\n\n  return result;\n};\n\n/**\n * Creates bound and wrapped function to store new value internally and invoke listener\n * If function is asyncronous, it waits for the promise to be resolved before firing\n *\n * @param {Singulum} singulum\n * @param {Function} fn\n * @param {string} key\n * @return {Function}\n */\nvar createWrapperFunction = function createWrapperFunction(singulum, fn, key) {\n  /**\n   * @note must be a standard function instead of an arrow function, to allow the this binding\n   */\n  return (0, _utils.bindFunction)(function () {\n    var _this = this;\n\n    var primaryArgument = key ? singulum.$$store[key] : singulum.$$store;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var result = fn.apply(undefined, [primaryArgument].concat(args));\n\n    /**\n     * If the result is a Promise, wait for resolution and then return the data\n     */\n    if ((0, _utils.isFunction)(result.then)) {\n      return result.then(function (resultValue) {\n        return updateStoreValue(_this, resultValue, key);\n      });\n    }\n\n    /**\n     * Otherwise, wrap the return data in a native Promise and return it\n     */\n    return Promise.resolve(updateStoreValue(this, result, key));\n  }, singulum);\n};\n\n/**\n * Creates namespaced Singulum within the object, aka make a branch\n *\n * @param {Singulum} singulum\n * @param {string} namespace\n * @param {Object} actions\n * @param {Object} initialValues\n * @returns {Object}\n */\nvar createNewSingulumNamespace = function createNewSingulumNamespace(singulum, namespace) {\n  var actions = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n  var initialValues = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n  /**\n   * if no namespace is provided, use the simple counter to create a unique entry\n   */\n  if (!namespace) {\n    namespace = namespaceIncrementer;\n    namespaceIncrementer++;\n  }\n\n  (0, _utils.setReadonly)(singulum, namespace, new Singulum(actions, initialValues));\n\n  singulum.$$store[namespace] = singulum[namespace];\n\n  return singulum[namespace];\n};\n\n/**\n * Creates new item in the store, and creates related action with wrapper\n *\n * @param {Singulum} singulum\n * @param {Object} actions\n * @param {Object} initialValues\n */\nvar createNewSingulumLeaves = function createNewSingulumLeaves(singulum) {\n  var actions = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n  var initialValues = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n  (0, _utils.forEachObject)(initialValues, function (initialValue, storeKey) {\n    /**\n     * Create separate clones for initialValues and store, so that references between\n     * the two do not exist\n     */\n    singulum.$$initialValues[storeKey] = (0, _utils.getClone)(initialValue, SingulumStore);\n    singulum.$$store[storeKey] = (0, _utils.getClone)(initialValue, SingulumStore);\n  });\n\n  (0, _utils.forEachObject)(actions, function (action, actionKey) {\n    /**\n     * if action is a function, then it applies to the entire state\n     */\n    if ((0, _utils.isFunction)(action)) {\n      singulum.$$actions[actionKey] = createWrapperFunction(singulum, action);\n    } else if ((0, _utils.isObject)(action)) {\n      /**\n       * if action is a map of functions, it applies to a specific key on the store\n       */\n      (0, _utils.forEachObject)(action, function (actionFn, actionFnKey) {\n        singulum.$$actions[actionFnKey] = createWrapperFunction(singulum, actionFn, actionKey);\n      });\n    }\n  });\n};\n\n/**\n * Gets clone of value from branch store based on key\n *\n * @param {Singulum} singulum\n * @param {string} key\n * @returns {*}\n */\nvar getLeaf = function getLeaf(singulum, key) {\n  return (0, _utils.getClone)(singulum.$$store[key], SingulumStore);\n};\n\n/**\n * Actions class provided with [branchName].actions\n */\n\nvar SingulumActions =\n/**\n * Create shallowly cloned and frozen object of internal actions, and freeze\n *\n * @param {Object} actions\n * @returns {Object}\n */\nfunction SingulumActions() {\n  var _this2 = this;\n\n  var actions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n  _classCallCheck(this, SingulumActions);\n\n  (0, _utils.forEachObject)(actions, function (value, key) {\n    _this2[key] = value;\n  });\n\n  OBJECT_FREEZE(this);\n\n  return this;\n};\n\n/**\n * Store class provided with [branchName].store\n */\n\n\nvar SingulumStore =\n/**\n * Create shallowly cloned and frozen object of store, including stores\n * branched from it\n *\n * @param {Object} store\n * @returns {Object}\n */\nfunction SingulumStore() {\n  var _this3 = this;\n\n  var store = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n  _classCallCheck(this, SingulumStore);\n\n  (0, _utils.forEachObject)(store, function (value, key) {\n    _this3[key] = (0, _utils.isInstanceOf)(value, Singulum) ? value.store : value;\n  });\n\n  OBJECT_FREEZE(this);\n\n  return this;\n};\n\n/**\n * Snapshot class provided with [branchName].snapshot();\n */\n\n\nvar SingulumSnapshot =\n/**\n * Create snapshot clone of store, optionally snapshotting deeply\n *\n * @param {SingulumStore} store\n * @param {Singulum} $$store\n * @param {boolean} snapshotBranches\n * @returns {Object}\n */\nfunction SingulumSnapshot() {\n  var store = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n  var _this4 = this;\n\n  var $$store = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n  var snapshotBranches = arguments[2];\n\n  _classCallCheck(this, SingulumSnapshot);\n\n  (0, _utils.forEachObject)(store, function (value, key) {\n    var $$value = $$store[key];\n\n    _this4[key] = (0, _utils.isInstanceOf)($$value, Singulum) && snapshotBranches ? new SingulumSnapshot($$value.store, $$value.$$store, snapshotBranches) : (0, _utils.getClone)($$value, SingulumStore);\n  });\n\n  return this;\n};\n\n/**\n * Main class\n */\n\n\nvar Singulum = function () {\n  /**\n   * Create singulum infrastructure, and populate leaves provided\n   *\n   * @param {Object} actions\n   * @param {Object} initialValues\n   * @returns {Singulum}\n   */\n\n  function Singulum() {\n    var actions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n    var initialValues = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Singulum);\n\n    (0, _utils.setHidden)(this, '$$actions', []);\n    (0, _utils.setHidden)(this, '$$initialValues', {});\n    (0, _utils.setHidden)(this, '$$watchers', []);\n    (0, _utils.setHidden)(this, '$$snapshots', {});\n    (0, _utils.setHidden)(this, '$$store', {});\n\n    createNewSingulumLeaves(this, actions, initialValues);\n\n    return this;\n  }\n\n  /**\n   * Get immutable version of actions\n   *\n   * @returns {SingulumActions}\n   */\n\n\n  _createClass(Singulum, [{\n    key: 'branch',\n\n\n    /**\n     * Create namespaced Singulum child\n     *\n     * @param {Object} actions\n     * @param {Object} initialValues\n     * @param {string} namespace\n     * @returns {Singulum}\n     */\n    value: function branch() {\n      var actions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n      var initialValues = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n      var namespace = arguments[2];\n\n      /**\n       * if a namespace is provided but it isn't a string value, make it one\n       */\n      if (namespace && !(0, _utils.isString)(namespace)) {\n        namespace = namespace.toString();\n      }\n\n      return createNewSingulumNamespace(this, namespace, actions, initialValues);\n    }\n\n    /**\n     * Determine if object passed is equal in value to the branch\n     * If key is passed, performs value equality check on branch[key] only\n     *\n     * @param {*} object\n     * @param {string} key\n     * @returns {*}\n     */\n\n  }, {\n    key: 'equals',\n    value: function equals(object, key) {\n      if (key) {\n        return (0, _utils.isEqual)(this.$$store[key], object[key]);\n      }\n\n      return (0, _utils.isEqual)(this.$$store, object);\n    }\n  }, {\n    key: 'hashCode',\n    value: function hashCode(key) {\n      if (key) {\n        return (0, _utils.hashCode)(this.$$store[key]);\n      }\n\n      return (0, _utils.hashCode)(this.$$store);\n    }\n\n    /**\n     * Based on key or array of keys, returns values in store associated\n     * If leaves is an array, an array of values in the same order as keys passed\n     * is returned\n     *\n     * @param {string|Array} leaves\n     * @returns {*}\n     */\n\n  }, {\n    key: 'pluck',\n    value: function pluck(leaves) {\n      var _this5 = this;\n\n      /**\n       * if nothing is passed, just return the store\n       */\n      if (!leaves) {\n        return this.store;\n      }\n\n      /**\n       * if its a single key, get the leaf\n       */\n      if ((0, _utils.isString)(leaves)) {\n        return getLeaf(this, leaves);\n      }\n\n      /**\n       * if its an array of keys, get all the leaves\n       */\n      if ((0, _utils.isArray)(leaves)) {\n        return leaves.map(function (leaf) {\n          return getLeaf(_this5, leaf);\n        });\n      }\n    }\n\n    /**\n     * Return singulum to its original state\n     *\n     * @param {boolean} resetBranches\n     * @returns {Singulum}\n     */\n\n  }, {\n    key: 'reset',\n    value: function reset() {\n      var _this6 = this;\n\n      var resetBranches = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n\n      var newStore = {};\n\n      (0, _utils.forEachObject)(this.$$store, function (value, key) {\n        if ((0, _utils.isInstanceOf)(value, Singulum) && resetBranches) {\n          /**\n           * if snapshot value is a Singulum and you want to reset child branches, then trigger\n           * .reset() on child branch\n           */\n          value.reset();\n        } else if (!(0, _utils.isInstanceOf)(value, SingulumSnapshot)) {\n          /**\n           * If the snapshot value is a non-Singulum value, re-apply it to the store\n           */\n          newStore[key] = _this6.$$initialValues[key];\n        }\n      });\n\n      this.$$store = newStore;\n\n      /**\n       * If there is a watcher, fire it\n       */\n      fireWatchers(this);\n\n      return this;\n    }\n\n    /**\n     * Restore values in store based on snapshot, optionally restored deeply\n     *\n     * @param {SingulumSnapshot} snapshot\n     * @param {boolean} restoreBranches\n     * @returns {Singulum}\n     */\n\n  }, {\n    key: 'restore',\n    value: function restore(snapshot) {\n      var _this7 = this;\n\n      var restoreBranches = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n      /**\n       * Make sure snapshot passed is a SingulumSnapshot\n       */\n      if (!(0, _utils.isInstanceOf)(snapshot, SingulumSnapshot)) {\n        (0, _utils.throwError)('Snapshot used in restore method must be a SingulumSnapshot.');\n      }\n\n      (0, _utils.forEachObject)(snapshot, function (value, key) {\n        if ((0, _utils.isInstanceOf)(value, SingulumSnapshot) && restoreBranches) {\n          /**\n           * if the snapshot value is a SingulumSnapshot and you want to reset\n           * child branches, then trigger restore on the child branch passing value\n           * as branch's snapshot\n           */\n          _this7.$$store[key].restore(value, restoreBranches);\n        } else if (!(0, _utils.isInstanceOf)(value, SingulumStore)) {\n          /**\n           * If the snapshot value is not a Singulum, re-apply it to the store\n           */\n          _this7.$$store[key] = value;\n        }\n      });\n\n      /**\n       * If there is a watcher, fire it\n       */\n      fireWatchers(this);\n\n      return this;\n    }\n\n    /**\n     * Create snapshot of current store state, optionally snapshot deeply\n     *\n     * @param {boolean} snapshotBranches\n     * @returns {SingulumSnapshot}\n     */\n\n  }, {\n    key: 'snapshot',\n    value: function snapshot() {\n      var snapshotBranches = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n\n      return new SingulumSnapshot(this.store, this.$$store, snapshotBranches);\n    }\n\n    /**\n     * Clear out callback bound to $$watchers\n     *\n     * @returns {Singulum}\n     */\n\n  }, {\n    key: 'unwatch',\n    value: function unwatch(callback) {\n      var watcherIndex = (0, _utils.findIndex)(this.$$watchers, function (watcher) {\n        return watcher === callback;\n      });\n\n      this.$$watchers = [].concat(_toConsumableArray(this.$$watchers.slice(0, watcherIndex)), _toConsumableArray(this.$$watchers.slice(watcherIndex + 1, this.$$watchers.length)));\n\n      return this;\n    }\n\n    /**\n     * Add callback to $$watchers, to be fired whenever store updates\n     *\n     * @param {Function} callback\n     * @returns {Singulum}\n     */\n\n  }, {\n    key: 'watch',\n    value: function watch(callback) {\n      /**\n       * Make sure callback is actually a function before setting it\n       */\n      if ((0, _utils.isFunction)(callback)) {\n        this.$$watchers = [].concat(_toConsumableArray(this.$$watchers), [callback]);\n      }\n\n      return this;\n    }\n  }, {\n    key: 'actions',\n    get: function get() {\n      return new SingulumActions(this.$$actions);\n    }\n\n    /**\n     * Get immutable version of store\n     *\n     * @returns {SingulumStore}\n     */\n\n  }, {\n    key: 'store',\n    get: function get() {\n      return new SingulumStore(this.$$store);\n    }\n  }]);\n\n  return Singulum;\n}();\n\nexports.default = Singulum;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvU2luZ3VsdW0uanM/ZGRiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBiaW5kRnVuY3Rpb24sXG4gIGZpbmRJbmRleCxcbiAgZm9yRWFjaE9iamVjdCxcbiAgZ2V0Q2xvbmUsXG4gIGhhc2hDb2RlLFxuICBpc0FycmF5LFxuICBpc0VxdWFsLFxuICBpc0Z1bmN0aW9uLFxuICBpc0luc3RhbmNlT2YsXG4gIGlzT2JqZWN0LFxuICBpc1N0cmluZyxcbiAgc2V0SGlkZGVuLFxuICBzZXRSZWFkb25seSxcbiAgdGhyb3dFcnJvclxufSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgT0JKRUNUX0ZSRUVaRSA9IE9iamVjdC5mcmVlemU7XG5cbi8qKlxuICogVGhpcyBpcyBhIGJhc2ljIGNvdW50ZXIgaW4gY2FzZSBhIG5hbWVzcGFjZSBpcyBub3QgcHJvdmlkZWQgd2hlbiBjcmVhdGluZ1xuICogYSBicmFuY2hcbiAqL1xubGV0IG5hbWVzcGFjZUluY3JlbWVudGVyID0gMDtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtTaW5ndWx1bX0gc2luZ3VsdW1cbiAqL1xuY29uc3QgZmlyZVdhdGNoZXJzID0gKHNpbmd1bHVtKSA9PiB7XG4gIHNpbmd1bHVtLiQkd2F0Y2hlcnMuZm9yRWFjaCgod2F0Y2hlcikgPT4ge1xuICAgIHdhdGNoZXIoc2luZ3VsdW0uc3RvcmUpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQXNzaWducyBuZXcgcmVzdWx0IHRvIHN0b3JlLCBmaXJlcyBsaXN0ZW5lciB3aXRoIG5ldyBTaW5ndWx1bVN0b3JlLCBhbmQgcmV0dXJuc1xuICogUHJvbWlzZSB3aXRoIG5ldyByZXN1bHRcbiAqXG4gKiBAcGFyYW0ge1Npbmd1bHVtfSBzaW5ndWx1bVxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSByZXN1bHRcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5jb25zdCB1cGRhdGVTdG9yZVZhbHVlID0gKHNpbmd1bHVtLCByZXN1bHQsIGtleSkgPT4ge1xuICAvKipcbiAgICogQXBwbHkgbmV3IHJlc3VsdCB2YWx1ZSB0byB0aGUgc3RvcmUsIHNjb3BlZCBpZiB0aGUga2V5IGlzIHByb3ZpZGVkXG4gICAqL1xuICBpZiAoa2V5KSB7XG4gICAgc2luZ3VsdW0uJCRzdG9yZVtrZXldID0gcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHNpbmd1bHVtLiQkc3RvcmUgPSByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlcmUgaXMgYSB3YXRjaGVyLCBmaXJlIGl0XG4gICAqL1xuICBmaXJlV2F0Y2hlcnMoc2luZ3VsdW0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYm91bmQgYW5kIHdyYXBwZWQgZnVuY3Rpb24gdG8gc3RvcmUgbmV3IHZhbHVlIGludGVybmFsbHkgYW5kIGludm9rZSBsaXN0ZW5lclxuICogSWYgZnVuY3Rpb24gaXMgYXN5bmNyb25vdXMsIGl0IHdhaXRzIGZvciB0aGUgcHJvbWlzZSB0byBiZSByZXNvbHZlZCBiZWZvcmUgZmlyaW5nXG4gKlxuICogQHBhcmFtIHtTaW5ndWx1bX0gc2luZ3VsdW1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuY29uc3QgY3JlYXRlV3JhcHBlckZ1bmN0aW9uID0gKHNpbmd1bHVtLCBmbiwga2V5KSA9PiB7XG4gIC8qKlxuICAgKiBAbm90ZSBtdXN0IGJlIGEgc3RhbmRhcmQgZnVuY3Rpb24gaW5zdGVhZCBvZiBhbiBhcnJvdyBmdW5jdGlvbiwgdG8gYWxsb3cgdGhlIHRoaXMgYmluZGluZ1xuICAgKi9cbiAgcmV0dXJuIGJpbmRGdW5jdGlvbihmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGNvbnN0IHByaW1hcnlBcmd1bWVudCA9IGtleSA/IHNpbmd1bHVtLiQkc3RvcmVba2V5XSA6IHNpbmd1bHVtLiQkc3RvcmU7XG4gICAgY29uc3QgcmVzdWx0ID0gZm4ocHJpbWFyeUFyZ3VtZW50LCAuLi5hcmdzKTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSByZXN1bHQgaXMgYSBQcm9taXNlLCB3YWl0IGZvciByZXNvbHV0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgZGF0YVxuICAgICAqL1xuICAgIGlmIChpc0Z1bmN0aW9uKHJlc3VsdC50aGVuKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHRWYWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gdXBkYXRlU3RvcmVWYWx1ZSh0aGlzLCByZXN1bHRWYWx1ZSwga2V5KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE90aGVyd2lzZSwgd3JhcCB0aGUgcmV0dXJuIGRhdGEgaW4gYSBuYXRpdmUgUHJvbWlzZSBhbmQgcmV0dXJuIGl0XG4gICAgICovXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1cGRhdGVTdG9yZVZhbHVlKHRoaXMsIHJlc3VsdCwga2V5KSk7XG4gIH0sIHNpbmd1bHVtKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBuYW1lc3BhY2VkIFNpbmd1bHVtIHdpdGhpbiB0aGUgb2JqZWN0LCBha2EgbWFrZSBhIGJyYW5jaFxuICpcbiAqIEBwYXJhbSB7U2luZ3VsdW19IHNpbmd1bHVtXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGluaXRpYWxWYWx1ZXNcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmNvbnN0IGNyZWF0ZU5ld1Npbmd1bHVtTmFtZXNwYWNlID0gKHNpbmd1bHVtLCBuYW1lc3BhY2UsIGFjdGlvbnMgPSB7fSwgaW5pdGlhbFZhbHVlcyA9IHt9KSA9PiB7XG4gIC8qKlxuICAgKiBpZiBubyBuYW1lc3BhY2UgaXMgcHJvdmlkZWQsIHVzZSB0aGUgc2ltcGxlIGNvdW50ZXIgdG8gY3JlYXRlIGEgdW5pcXVlIGVudHJ5XG4gICAqL1xuICBpZiAoIW5hbWVzcGFjZSkge1xuICAgIG5hbWVzcGFjZSA9IG5hbWVzcGFjZUluY3JlbWVudGVyO1xuICAgIG5hbWVzcGFjZUluY3JlbWVudGVyKys7XG4gIH1cblxuICBzZXRSZWFkb25seShzaW5ndWx1bSwgbmFtZXNwYWNlLCBuZXcgU2luZ3VsdW0oYWN0aW9ucywgaW5pdGlhbFZhbHVlcykpO1xuXG4gIHNpbmd1bHVtLiQkc3RvcmVbbmFtZXNwYWNlXSA9IHNpbmd1bHVtW25hbWVzcGFjZV07XG5cbiAgcmV0dXJuIHNpbmd1bHVtW25hbWVzcGFjZV07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGl0ZW0gaW4gdGhlIHN0b3JlLCBhbmQgY3JlYXRlcyByZWxhdGVkIGFjdGlvbiB3aXRoIHdyYXBwZXJcbiAqXG4gKiBAcGFyYW0ge1Npbmd1bHVtfSBzaW5ndWx1bVxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbml0aWFsVmFsdWVzXG4gKi9cbmNvbnN0IGNyZWF0ZU5ld1Npbmd1bHVtTGVhdmVzID0gKHNpbmd1bHVtLCBhY3Rpb25zID0ge30sIGluaXRpYWxWYWx1ZXMgPSB7fSkgPT4ge1xuICBmb3JFYWNoT2JqZWN0KGluaXRpYWxWYWx1ZXMsIChpbml0aWFsVmFsdWUsIHN0b3JlS2V5KSA9PiB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHNlcGFyYXRlIGNsb25lcyBmb3IgaW5pdGlhbFZhbHVlcyBhbmQgc3RvcmUsIHNvIHRoYXQgcmVmZXJlbmNlcyBiZXR3ZWVuXG4gICAgICogdGhlIHR3byBkbyBub3QgZXhpc3RcbiAgICAgKi9cbiAgICBzaW5ndWx1bS4kJGluaXRpYWxWYWx1ZXNbc3RvcmVLZXldID0gZ2V0Q2xvbmUoaW5pdGlhbFZhbHVlLCBTaW5ndWx1bVN0b3JlKTtcbiAgICBzaW5ndWx1bS4kJHN0b3JlW3N0b3JlS2V5XSA9IGdldENsb25lKGluaXRpYWxWYWx1ZSwgU2luZ3VsdW1TdG9yZSk7XG4gIH0pO1xuXG4gIGZvckVhY2hPYmplY3QoYWN0aW9ucywgKGFjdGlvbiwgYWN0aW9uS2V5KSA9PiB7XG4gICAgLyoqXG4gICAgICogaWYgYWN0aW9uIGlzIGEgZnVuY3Rpb24sIHRoZW4gaXQgYXBwbGllcyB0byB0aGUgZW50aXJlIHN0YXRlXG4gICAgICovXG4gICAgaWYgKGlzRnVuY3Rpb24oYWN0aW9uKSkge1xuICAgICAgc2luZ3VsdW0uJCRhY3Rpb25zW2FjdGlvbktleV0gPSBjcmVhdGVXcmFwcGVyRnVuY3Rpb24oc2luZ3VsdW0sIGFjdGlvbik7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChhY3Rpb24pKSB7XG4gICAgICAvKipcbiAgICAgICAqIGlmIGFjdGlvbiBpcyBhIG1hcCBvZiBmdW5jdGlvbnMsIGl0IGFwcGxpZXMgdG8gYSBzcGVjaWZpYyBrZXkgb24gdGhlIHN0b3JlXG4gICAgICAgKi9cbiAgICAgIGZvckVhY2hPYmplY3QoYWN0aW9uLCAoYWN0aW9uRm4sIGFjdGlvbkZuS2V5KSA9PiB7XG4gICAgICAgIHNpbmd1bHVtLiQkYWN0aW9uc1thY3Rpb25GbktleV0gPSBjcmVhdGVXcmFwcGVyRnVuY3Rpb24oc2luZ3VsdW0sIGFjdGlvbkZuLCBhY3Rpb25LZXkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogR2V0cyBjbG9uZSBvZiB2YWx1ZSBmcm9tIGJyYW5jaCBzdG9yZSBiYXNlZCBvbiBrZXlcbiAqXG4gKiBAcGFyYW0ge1Npbmd1bHVtfSBzaW5ndWx1bVxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybnMgeyp9XG4gKi9cbmNvbnN0IGdldExlYWYgPSAoc2luZ3VsdW0sIGtleSkgPT4ge1xuICByZXR1cm4gZ2V0Q2xvbmUoc2luZ3VsdW0uJCRzdG9yZVtrZXldLCBTaW5ndWx1bVN0b3JlKTtcbn07XG5cbi8qKlxuICogQWN0aW9ucyBjbGFzcyBwcm92aWRlZCB3aXRoIFticmFuY2hOYW1lXS5hY3Rpb25zXG4gKi9cbmNsYXNzIFNpbmd1bHVtQWN0aW9ucyB7XG4gIC8qKlxuICAgKiBDcmVhdGUgc2hhbGxvd2x5IGNsb25lZCBhbmQgZnJvemVuIG9iamVjdCBvZiBpbnRlcm5hbCBhY3Rpb25zLCBhbmQgZnJlZXplXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb25zXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihhY3Rpb25zID0ge30pIHtcbiAgICBmb3JFYWNoT2JqZWN0KGFjdGlvbnMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIE9CSkVDVF9GUkVFWkUodGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4vKipcbiAqIFN0b3JlIGNsYXNzIHByb3ZpZGVkIHdpdGggW2JyYW5jaE5hbWVdLnN0b3JlXG4gKi9cbmNsYXNzIFNpbmd1bHVtU3RvcmUge1xuICAvKipcbiAgICogQ3JlYXRlIHNoYWxsb3dseSBjbG9uZWQgYW5kIGZyb3plbiBvYmplY3Qgb2Ygc3RvcmUsIGluY2x1ZGluZyBzdG9yZXNcbiAgICogYnJhbmNoZWQgZnJvbSBpdFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RvcmVcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHN0b3JlID0ge30pIHtcbiAgICBmb3JFYWNoT2JqZWN0KHN0b3JlLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgdGhpc1trZXldID0gaXNJbnN0YW5jZU9mKHZhbHVlLCBTaW5ndWx1bSkgPyB2YWx1ZS5zdG9yZSA6IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgT0JKRUNUX0ZSRUVaRSh0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8qKlxuICogU25hcHNob3QgY2xhc3MgcHJvdmlkZWQgd2l0aCBbYnJhbmNoTmFtZV0uc25hcHNob3QoKTtcbiAqL1xuY2xhc3MgU2luZ3VsdW1TbmFwc2hvdCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgc25hcHNob3QgY2xvbmUgb2Ygc3RvcmUsIG9wdGlvbmFsbHkgc25hcHNob3R0aW5nIGRlZXBseVxuICAgKlxuICAgKiBAcGFyYW0ge1Npbmd1bHVtU3RvcmV9IHN0b3JlXG4gICAqIEBwYXJhbSB7U2luZ3VsdW19ICQkc3RvcmVcbiAgICogQHBhcmFtIHtib29sZWFufSBzbmFwc2hvdEJyYW5jaGVzXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihzdG9yZSA9IHt9LCAkJHN0b3JlID0ge30sIHNuYXBzaG90QnJhbmNoZXMpIHtcbiAgICBmb3JFYWNoT2JqZWN0KHN0b3JlLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgY29uc3QgJCR2YWx1ZSA9ICQkc3RvcmVba2V5XTtcblxuICAgICAgdGhpc1trZXldID0gaXNJbnN0YW5jZU9mKCQkdmFsdWUsIFNpbmd1bHVtKSAmJiBzbmFwc2hvdEJyYW5jaGVzID9cbiAgICAgICAgbmV3IFNpbmd1bHVtU25hcHNob3QoJCR2YWx1ZS5zdG9yZSwgJCR2YWx1ZS4kJHN0b3JlLCBzbmFwc2hvdEJyYW5jaGVzKSA6XG4gICAgICAgIGdldENsb25lKCQkdmFsdWUsIFNpbmd1bHVtU3RvcmUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuLyoqXG4gKiBNYWluIGNsYXNzXG4gKi9cbmNsYXNzIFNpbmd1bHVtIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBzaW5ndWx1bSBpbmZyYXN0cnVjdHVyZSwgYW5kIHBvcHVsYXRlIGxlYXZlcyBwcm92aWRlZFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gaW5pdGlhbFZhbHVlc1xuICAgKiBAcmV0dXJucyB7U2luZ3VsdW19XG4gICAqL1xuICBjb25zdHJ1Y3RvcihhY3Rpb25zID0ge30sIGluaXRpYWxWYWx1ZXMgPSB7fSkge1xuICAgIHNldEhpZGRlbih0aGlzLCAnJCRhY3Rpb25zJywgW10pO1xuICAgIHNldEhpZGRlbih0aGlzLCAnJCRpbml0aWFsVmFsdWVzJywge30pO1xuICAgIHNldEhpZGRlbih0aGlzLCAnJCR3YXRjaGVycycsIFtdKTtcbiAgICBzZXRIaWRkZW4odGhpcywgJyQkc25hcHNob3RzJywge30pO1xuICAgIHNldEhpZGRlbih0aGlzLCAnJCRzdG9yZScsIHt9KTtcblxuICAgIGNyZWF0ZU5ld1Npbmd1bHVtTGVhdmVzKHRoaXMsIGFjdGlvbnMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGltbXV0YWJsZSB2ZXJzaW9uIG9mIGFjdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Npbmd1bHVtQWN0aW9uc31cbiAgICovXG4gIGdldCBhY3Rpb25zKCkge1xuICAgIHJldHVybiBuZXcgU2luZ3VsdW1BY3Rpb25zKHRoaXMuJCRhY3Rpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW1tdXRhYmxlIHZlcnNpb24gb2Ygc3RvcmVcbiAgICpcbiAgICogQHJldHVybnMge1Npbmd1bHVtU3RvcmV9XG4gICAqL1xuICBnZXQgc3RvcmUoKSB7XG4gICAgcmV0dXJuIG5ldyBTaW5ndWx1bVN0b3JlKHRoaXMuJCRzdG9yZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIG5hbWVzcGFjZWQgU2luZ3VsdW0gY2hpbGRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGluaXRpYWxWYWx1ZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZVxuICAgKiBAcmV0dXJucyB7U2luZ3VsdW19XG4gICAqL1xuICBicmFuY2goYWN0aW9ucyA9IHt9LCBpbml0aWFsVmFsdWVzID0ge30sIG5hbWVzcGFjZSkge1xuICAgIC8qKlxuICAgICAqIGlmIGEgbmFtZXNwYWNlIGlzIHByb3ZpZGVkIGJ1dCBpdCBpc24ndCBhIHN0cmluZyB2YWx1ZSwgbWFrZSBpdCBvbmVcbiAgICAgKi9cbiAgICBpZiAobmFtZXNwYWNlICYmICFpc1N0cmluZyhuYW1lc3BhY2UpKSB7XG4gICAgICBuYW1lc3BhY2UgPSBuYW1lc3BhY2UudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlTmV3U2luZ3VsdW1OYW1lc3BhY2UodGhpcywgbmFtZXNwYWNlLCBhY3Rpb25zLCBpbml0aWFsVmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgb2JqZWN0IHBhc3NlZCBpcyBlcXVhbCBpbiB2YWx1ZSB0byB0aGUgYnJhbmNoXG4gICAqIElmIGtleSBpcyBwYXNzZWQsIHBlcmZvcm1zIHZhbHVlIGVxdWFsaXR5IGNoZWNrIG9uIGJyYW5jaFtrZXldIG9ubHlcbiAgICpcbiAgICogQHBhcmFtIHsqfSBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGVxdWFscyhvYmplY3QsIGtleSkge1xuICAgIGlmIChrZXkpIHtcbiAgICAgIHJldHVybiBpc0VxdWFsKHRoaXMuJCRzdG9yZVtrZXldLCBvYmplY3Rba2V5XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzRXF1YWwodGhpcy4kJHN0b3JlLCBvYmplY3QpO1xuICB9XG5cbiAgaGFzaENvZGUoa2V5KSB7XG4gICAgaWYgKGtleSkge1xuICAgICAgcmV0dXJuIGhhc2hDb2RlKHRoaXMuJCRzdG9yZVtrZXldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaENvZGUodGhpcy4kJHN0b3JlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXNlZCBvbiBrZXkgb3IgYXJyYXkgb2Yga2V5cywgcmV0dXJucyB2YWx1ZXMgaW4gc3RvcmUgYXNzb2NpYXRlZFxuICAgKiBJZiBsZWF2ZXMgaXMgYW4gYXJyYXksIGFuIGFycmF5IG9mIHZhbHVlcyBpbiB0aGUgc2FtZSBvcmRlciBhcyBrZXlzIHBhc3NlZFxuICAgKiBpcyByZXR1cm5lZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gbGVhdmVzXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgcGx1Y2sobGVhdmVzKSB7XG4gICAgLyoqXG4gICAgICogaWYgbm90aGluZyBpcyBwYXNzZWQsIGp1c3QgcmV0dXJuIHRoZSBzdG9yZVxuICAgICAqL1xuICAgIGlmICghbGVhdmVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdG9yZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpZiBpdHMgYSBzaW5nbGUga2V5LCBnZXQgdGhlIGxlYWZcbiAgICAgKi9cbiAgICBpZiAoaXNTdHJpbmcobGVhdmVzKSkge1xuICAgICAgcmV0dXJuIGdldExlYWYodGhpcywgbGVhdmVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpZiBpdHMgYW4gYXJyYXkgb2Yga2V5cywgZ2V0IGFsbCB0aGUgbGVhdmVzXG4gICAgICovXG4gICAgaWYgKGlzQXJyYXkobGVhdmVzKSkge1xuICAgICAgcmV0dXJuIGxlYXZlcy5tYXAoKGxlYWYpID0+IHtcbiAgICAgICAgcmV0dXJuIGdldExlYWYodGhpcywgbGVhZik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHNpbmd1bHVtIHRvIGl0cyBvcmlnaW5hbCBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc2V0QnJhbmNoZXNcbiAgICogQHJldHVybnMge1Npbmd1bHVtfVxuICAgKi9cbiAgcmVzZXQocmVzZXRCcmFuY2hlcyA9IGZhbHNlKSB7XG4gICAgbGV0IG5ld1N0b3JlID0ge307XG5cbiAgICBmb3JFYWNoT2JqZWN0KHRoaXMuJCRzdG9yZSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGlmIChpc0luc3RhbmNlT2YodmFsdWUsIFNpbmd1bHVtKSAmJiByZXNldEJyYW5jaGVzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpZiBzbmFwc2hvdCB2YWx1ZSBpcyBhIFNpbmd1bHVtIGFuZCB5b3Ugd2FudCB0byByZXNldCBjaGlsZCBicmFuY2hlcywgdGhlbiB0cmlnZ2VyXG4gICAgICAgICAqIC5yZXNldCgpIG9uIGNoaWxkIGJyYW5jaFxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWUucmVzZXQoKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzSW5zdGFuY2VPZih2YWx1ZSwgU2luZ3VsdW1TbmFwc2hvdCkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBzbmFwc2hvdCB2YWx1ZSBpcyBhIG5vbi1TaW5ndWx1bSB2YWx1ZSwgcmUtYXBwbHkgaXQgdG8gdGhlIHN0b3JlXG4gICAgICAgICAqL1xuICAgICAgICBuZXdTdG9yZVtrZXldID0gdGhpcy4kJGluaXRpYWxWYWx1ZXNba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuJCRzdG9yZSA9IG5ld1N0b3JlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlcmUgaXMgYSB3YXRjaGVyLCBmaXJlIGl0XG4gICAgICovXG4gICAgZmlyZVdhdGNoZXJzKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZSB2YWx1ZXMgaW4gc3RvcmUgYmFzZWQgb24gc25hcHNob3QsIG9wdGlvbmFsbHkgcmVzdG9yZWQgZGVlcGx5XG4gICAqXG4gICAqIEBwYXJhbSB7U2luZ3VsdW1TbmFwc2hvdH0gc25hcHNob3RcbiAgICogQHBhcmFtIHtib29sZWFufSByZXN0b3JlQnJhbmNoZXNcbiAgICogQHJldHVybnMge1Npbmd1bHVtfVxuICAgKi9cbiAgcmVzdG9yZShzbmFwc2hvdCwgcmVzdG9yZUJyYW5jaGVzID0gZmFsc2UpIHtcbiAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgc25hcHNob3QgcGFzc2VkIGlzIGEgU2luZ3VsdW1TbmFwc2hvdFxuICAgICAqL1xuICAgIGlmICghaXNJbnN0YW5jZU9mKHNuYXBzaG90LCBTaW5ndWx1bVNuYXBzaG90KSkge1xuICAgICAgdGhyb3dFcnJvcignU25hcHNob3QgdXNlZCBpbiByZXN0b3JlIG1ldGhvZCBtdXN0IGJlIGEgU2luZ3VsdW1TbmFwc2hvdC4nKTtcbiAgICB9XG5cbiAgICBmb3JFYWNoT2JqZWN0KHNuYXBzaG90LCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgaWYgKGlzSW5zdGFuY2VPZih2YWx1ZSwgU2luZ3VsdW1TbmFwc2hvdCkgJiYgcmVzdG9yZUJyYW5jaGVzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpZiB0aGUgc25hcHNob3QgdmFsdWUgaXMgYSBTaW5ndWx1bVNuYXBzaG90IGFuZCB5b3Ugd2FudCB0byByZXNldFxuICAgICAgICAgKiBjaGlsZCBicmFuY2hlcywgdGhlbiB0cmlnZ2VyIHJlc3RvcmUgb24gdGhlIGNoaWxkIGJyYW5jaCBwYXNzaW5nIHZhbHVlXG4gICAgICAgICAqIGFzIGJyYW5jaCdzIHNuYXBzaG90XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiQkc3RvcmVba2V5XS5yZXN0b3JlKHZhbHVlLCByZXN0b3JlQnJhbmNoZXMpO1xuICAgICAgfSBlbHNlIGlmICghaXNJbnN0YW5jZU9mKHZhbHVlLCBTaW5ndWx1bVN0b3JlKSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHNuYXBzaG90IHZhbHVlIGlzIG5vdCBhIFNpbmd1bHVtLCByZS1hcHBseSBpdCB0byB0aGUgc3RvcmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJCRzdG9yZVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSBpcyBhIHdhdGNoZXIsIGZpcmUgaXRcbiAgICAgKi9cbiAgICBmaXJlV2F0Y2hlcnModGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgc25hcHNob3Qgb2YgY3VycmVudCBzdG9yZSBzdGF0ZSwgb3B0aW9uYWxseSBzbmFwc2hvdCBkZWVwbHlcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBzbmFwc2hvdEJyYW5jaGVzXG4gICAqIEByZXR1cm5zIHtTaW5ndWx1bVNuYXBzaG90fVxuICAgKi9cbiAgc25hcHNob3Qoc25hcHNob3RCcmFuY2hlcyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIG5ldyBTaW5ndWx1bVNuYXBzaG90KHRoaXMuc3RvcmUsIHRoaXMuJCRzdG9yZSwgc25hcHNob3RCcmFuY2hlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgb3V0IGNhbGxiYWNrIGJvdW5kIHRvICQkd2F0Y2hlcnNcbiAgICpcbiAgICogQHJldHVybnMge1Npbmd1bHVtfVxuICAgKi9cbiAgdW53YXRjaChjYWxsYmFjaykge1xuICAgIGNvbnN0IHdhdGNoZXJJbmRleCA9IGZpbmRJbmRleCh0aGlzLiQkd2F0Y2hlcnMsICh3YXRjaGVyKSA9PiB7XG4gICAgICByZXR1cm4gd2F0Y2hlciA9PT0gY2FsbGJhY2s7XG4gICAgfSk7XG5cbiAgICB0aGlzLiQkd2F0Y2hlcnMgPSBbXG4gICAgICAuLi50aGlzLiQkd2F0Y2hlcnMuc2xpY2UoMCwgd2F0Y2hlckluZGV4KSxcbiAgICAgIC4uLnRoaXMuJCR3YXRjaGVycy5zbGljZSh3YXRjaGVySW5kZXggKyAxLCB0aGlzLiQkd2F0Y2hlcnMubGVuZ3RoKVxuICAgIF07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2sgdG8gJCR3YXRjaGVycywgdG8gYmUgZmlyZWQgd2hlbmV2ZXIgc3RvcmUgdXBkYXRlc1xuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7U2luZ3VsdW19XG4gICAqL1xuICB3YXRjaChjYWxsYmFjaykge1xuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VyZSBjYWxsYmFjayBpcyBhY3R1YWxseSBhIGZ1bmN0aW9uIGJlZm9yZSBzZXR0aW5nIGl0XG4gICAgICovXG4gICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICB0aGlzLiQkd2F0Y2hlcnMgPSBbXG4gICAgICAgIC4uLnRoaXMuJCR3YXRjaGVycyxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgIF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2luZ3VsdW07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogc3JjL1Npbmd1bHVtLmpzXG4gKiovIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBOzs7Ozs7Ozs7O0FBY0E7Ozs7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBQ0E7Ozs7QUFMQTtBQUNBO0FBY0E7QUFmQTtBQUNBOzs7Ozs7Ozs7O0FBMEJBOzs7O0FBSUE7OztBQUNBO0FBQ0E7QUFGQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUhBO0FBUUE7QUFDQTtBQURBO0FBREE7QUFDQTs7OztBQVJBO0FBQUE7QUFKQTtBQUNBOzs7Ozs7Ozs7O0FBZ0NBO0FBQUE7QUFBQTtBQUNBOzs7O0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQUNBOzs7Ozs7OztBQXNCQTtBQUFBO0FBQUE7QUFDQTtBQUFBOzs7OztBQUtBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7Ozs7QUFJQTtBQUNBO0FBREE7Ozs7QUFNQTtBQUNBO0FBREE7QUFKQTtBQU5BO0FBVkE7QUFDQTs7Ozs7Ozs7QUFpQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBTUE7Ozs7Ozs7QUFPQTs7O0FBQUE7QUFDQTtBQVJBO0FBQ0E7QUFPQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7Ozs7OztBQWFBOzs7Ozs7OztBQVFBOzs7QUFBQTtBQUNBO0FBVEE7QUFDQTtBQVFBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBUEE7QUFDQTs7Ozs7O0FBYUE7Ozs7Ozs7OztBQVNBO0FBQUE7QUFDQTs7O0FBREE7QUFBQTtBQUNBO0FBVkE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQU9BO0FBVEE7QUFDQTs7Ozs7O0FBZUE7Ozs7Ozs7OztBQVFBO0FBQUE7QUFBQTtBQUNBO0FBVEE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7Ozs7Ozs7O0FBVEE7Ozs7Ozs7Ozs7OztBQThDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7O0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTs7Ozs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7Ozs7Ozs7Ozs7Ozs7O0FBV0E7Ozs7OztBQUlBO0FBQ0E7QUFEQTtBQUNBOzs7O0FBTEE7QUFZQTtBQURBO0FBQ0E7Ozs7QUFaQTtBQW1CQTtBQUNBO0FBREE7QUFEQTs7Ozs7Ozs7Ozs7O0FBYUE7OztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUxBOzs7O0FBVUE7QUFKQTtBQVBBO0FBQ0E7QUFjQTtBQUNBOzs7O0FBbkJBO0FBQ0E7QUF3QkE7Ozs7Ozs7Ozs7Ozs7QUFVQTs7O0FBQUE7QUFDQTs7OztBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTs7Ozs7O0FBTUE7QUFOQTs7OztBQVdBO0FBSkE7QUFSQTtBQUNBOzs7O0FBVEE7QUFDQTtBQTRCQTs7Ozs7Ozs7Ozs7O0FBU0E7QUFBQTtBQUNBO0FBQUE7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFJQTs7Ozs7Ozs7Ozs7O0FBU0E7Ozs7QUFJQTtBQUNBO0FBREE7QUFDQTtBQU1BOzs7O0FBL01BO0FBQ0E7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTs7OztBQW5DQTs7O0FBNE9BOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar TO_STRING = Object.prototype.toString;\n\n/**\n * Binds function to thisArg\n *\n * @param {Function} fn\n * @param {Object} thisArg\n * @returns {Function}\n */\nvar bindFunction = exports.bindFunction = function bindFunction(fn, thisArg) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return fn.apply(thisArg, args);\n  };\n};\n\n/**\n * Finds the index in the array where the callback returns a truthy value\n *\n * @param {Array} array\n * @param {Function} callback\n * @returns {number}\n */\nvar findIndex = exports.findIndex = function findIndex(array, callback) {\n  for (var index = 0, length = array.length; index < length; index++) {\n    if (callback(array[index], index, array)) {\n      return index;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Provided as faster alternative for native .forEach\n *\n * @param {Object} object\n * @param {Function} fn\n */\nvar forEachObject = exports.forEachObject = function forEachObject(object, fn) {\n  var keysArray = Object.keys(object);\n\n  for (var index = 0, length = keysArray.length; index < length; index++) {\n    var key = keysArray[index];\n\n    fn(object[key], key, object);\n  }\n};\n\n/**\n * Returns clone of Singulum object with metadata stripped and child\n * stores with SingulumStore class applied\n *\n * @param {*} object\n * @param {SingulumStore} SingulumStore\n * @returns {*}\n */\nvar getClone = exports.getClone = function getClone(object, SingulumStore) {\n  if (isArray(object)) {\n    return object.map(function (item) {\n      return getClone(item, SingulumStore);\n    });\n  }\n\n  if (isObject(object)) {\n    var _ret = function () {\n      var cloneObject = {};\n\n      forEachObject(object, function (value, key) {\n        cloneObject[key] = getClone(value, SingulumStore);\n      });\n\n      if (isInstanceOf(object, SingulumStore)) {\n        cloneObject = new SingulumStore(cloneObject);\n      }\n\n      return {\n        v: cloneObject\n      };\n    }();\n\n    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n  }\n\n  if (isDate(object)) {\n    return new Date(object.valueOf());\n  }\n\n  return object;\n};\n\n/**\n * Build integer hashCode from object\n *\n * @param {*} object\n * @returns {number}\n */\nvar hashCode = exports.hashCode = function hashCode(object) {\n  var serializedObject = serialize(object);\n\n  if (serializedObject === '') {\n    return 0;\n  }\n\n  var hashCode = 0,\n      char = undefined;\n\n  for (var index = 0, length = serializedObject.length; index < length; index++) {\n    char = serializedObject.charCodeAt(index);\n    hashCode = (hashCode << 5) - hashCode + char;\n    hashCode |= 0;\n  }\n\n  return hashCode;\n};\n\n/**\n * Determines if object is of type Array\n *\n * @param {*} object\n * @returns {boolean}\n */\nvar isArray = exports.isArray = function isArray(object) {\n  return TO_STRING.call(object) === '[object Array]';\n};\n\n/**\n * Determines if object is of type Date\n * Not exported because not used elsewhere\n *\n * @param {*} object\n * @returns {boolean}\n */\nvar isDate = function isDate(object) {\n  return TO_STRING.call(object) === '[object Date]';\n};\n\n/**\n * Determines if the two objects have equal values (checks deeply)\n *\n * @param {*} object1\n * @param {*} object2\n * @returns {*}\n */\nvar isEqual = exports.isEqual = function isEqual(object1, object2) {\n  return hashCode(object1) === hashCode(object2);\n};\n\n/**\n * Determines if object is of type Function\n *\n * @param {*} object\n * @returns {boolean}\n */\nvar isFunction = exports.isFunction = function isFunction(object) {\n  return TO_STRING.call(object) === '[object Function]' || typeof object === 'function';\n};\n\n/**\n * Determine if object is instance of Constructor\n *\n * @param {*} object\n * @param {Function} Constructor\n * @returns {boolean}\n */\nvar isInstanceOf = exports.isInstanceOf = function isInstanceOf(object, Constructor) {\n  return object instanceof Constructor;\n};\n\n/**\n * Determines if object is of type Object\n *\n * @param {*} object\n * @returns {boolean}\n */\nvar isObject = exports.isObject = function isObject(object) {\n  return TO_STRING.call(object) === '[object Object]' && !!object;\n};\n\n/**\n * Determines if object is of type String\n *\n * @param {*} object\n * @returns {boolean}\n */\nvar isString = exports.isString = function isString(object) {\n  return TO_STRING.call(object) === '[object String]';\n};\n\n/**\n * Set property to be non-enumerable\n *\n * @param {Object} object\n * @param {string} property\n * @param {*} value\n */\nvar setHidden = exports.setHidden = function setHidden(object, property, value) {\n  Object.defineProperty(object, property, {\n    configurable: true,\n    enumerable: false,\n    value: value,\n    writable: true\n  });\n};\n\n/**\n * Serialize object into string value, to be used for hashing\n *\n * @param {*} object\n * @returns {string}\n */\nvar serialize = function serialize(object) {\n  var type = typeof object === 'undefined' ? 'undefined' : _typeof(object);\n\n  var serializedCode = '';\n\n  if (type === 'object') {\n    for (var element in object) {\n      serializedCode += '{' + type + ':' + element + serialize(object[element]) + '}';\n    }\n  } else if (type === 'function') {\n    serializedCode += '{' + type + ':' + object.toString() + '}';\n  } else {\n    serializedCode += '{' + type + ':' + object + '}';\n  }\n\n  return serializedCode.replace(/\\s/g, '');\n};\n\n/**\n * Set property on object as getter only, making it immutable\n *\n * @param {Object} object\n * @param {string} property\n * @param {*} value\n */\nvar setReadonly = exports.setReadonly = function setReadonly(object, property, value) {\n  Object.defineProperty(object, property, {\n    get: function get() {\n      return value;\n    },\n    set: function set() {\n      throwError('Cannot set a value for ' + property + ', as it is immutable.');\n    }\n  });\n};\n\n/**\n * Consolidated error throwing function, mainly for minification benefits\n *\n * @param {string} error\n */\nvar throwError = exports.throwError = function throwError(error) {\n  throw new Error(error);\n};\n\nexports.default = {\n  bindFunction: bindFunction,\n  findIndex: findIndex,\n  forEachObject: forEachObject,\n  getClone: getClone,\n  hashCode: hashCode,\n  isArray: isArray,\n  isEqual: isEqual,\n  isFunction: isFunction,\n  isInstanceOf: isInstanceOf,\n  isObject: isObject,\n  isString: isString,\n  setHidden: setHidden,\n  setReadonly: setReadonly,\n  throwError: throwError\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdXRpbHMuanM/MmI0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBUT19TVFJJTkcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIEJpbmRzIGZ1bmN0aW9uIHRvIHRoaXNBcmdcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmdcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGJpbmRGdW5jdGlvbiA9IChmbiwgdGhpc0FyZykgPT4ge1xuICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuXG4vKipcbiAqIEZpbmRzIHRoZSBpbmRleCBpbiB0aGUgYXJyYXkgd2hlcmUgdGhlIGNhbGxiYWNrIHJldHVybnMgYSB0cnV0aHkgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBmaW5kSW5kZXggPSAoYXJyYXksIGNhbGxiYWNrKSA9PiB7XG4gIGZvciAobGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGlmIChjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVkIGFzIGZhc3RlciBhbHRlcm5hdGl2ZSBmb3IgbmF0aXZlIC5mb3JFYWNoXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZXhwb3J0IGNvbnN0IGZvckVhY2hPYmplY3QgPSAob2JqZWN0LCBmbikgPT4ge1xuICBjb25zdCBrZXlzQXJyYXkgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMCwgbGVuZ3RoID0ga2V5c0FycmF5Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzQXJyYXlbaW5kZXhdO1xuXG4gICAgZm4ob2JqZWN0W2tleV0sIGtleSwgb2JqZWN0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGNsb25lIG9mIFNpbmd1bHVtIG9iamVjdCB3aXRoIG1ldGFkYXRhIHN0cmlwcGVkIGFuZCBjaGlsZFxuICogc3RvcmVzIHdpdGggU2luZ3VsdW1TdG9yZSBjbGFzcyBhcHBsaWVkXG4gKlxuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEBwYXJhbSB7U2luZ3VsdW1TdG9yZX0gU2luZ3VsdW1TdG9yZVxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDbG9uZSA9IChvYmplY3QsIFNpbmd1bHVtU3RvcmUpID0+IHtcbiAgaWYgKGlzQXJyYXkob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3QubWFwKChpdGVtKSA9PiB7XG4gICAgICByZXR1cm4gZ2V0Q2xvbmUoaXRlbSwgU2luZ3VsdW1TdG9yZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIGxldCBjbG9uZU9iamVjdCA9IHt9O1xuXG4gICAgZm9yRWFjaE9iamVjdChvYmplY3QsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBjbG9uZU9iamVjdFtrZXldID0gZ2V0Q2xvbmUodmFsdWUsIFNpbmd1bHVtU3RvcmUpO1xuICAgIH0pO1xuXG4gICAgaWYgKGlzSW5zdGFuY2VPZihvYmplY3QsIFNpbmd1bHVtU3RvcmUpKSB7XG4gICAgICBjbG9uZU9iamVjdCA9IG5ldyBTaW5ndWx1bVN0b3JlKGNsb25lT2JqZWN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmVPYmplY3Q7XG4gIH1cblxuICBpZiAoaXNEYXRlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0LnZhbHVlT2YoKSk7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufTtcblxuLyoqXG4gKiBCdWlsZCBpbnRlZ2VyIGhhc2hDb2RlIGZyb20gb2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBoYXNoQ29kZSA9IChvYmplY3QpID0+IHtcbiAgY29uc3Qgc2VyaWFsaXplZE9iamVjdCA9IHNlcmlhbGl6ZShvYmplY3QpO1xuXG4gIGlmIChzZXJpYWxpemVkT2JqZWN0ID09PSAnJykge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgbGV0IGhhc2hDb2RlID0gMCxcbiAgICAgIGNoYXI7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBzZXJpYWxpemVkT2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBjaGFyID0gc2VyaWFsaXplZE9iamVjdC5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICBoYXNoQ29kZSA9ICgoaGFzaENvZGUgPDwgNSkgLSBoYXNoQ29kZSkgKyBjaGFyO1xuICAgIGhhc2hDb2RlIHw9IDA7XG4gIH1cblxuICByZXR1cm4gaGFzaENvZGU7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgb2JqZWN0IGlzIG9mIHR5cGUgQXJyYXlcbiAqXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc0FycmF5ID0gKG9iamVjdCkgPT4ge1xuICByZXR1cm4gVE9fU1RSSU5HLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBvYmplY3QgaXMgb2YgdHlwZSBEYXRlXG4gKiBOb3QgZXhwb3J0ZWQgYmVjYXVzZSBub3QgdXNlZCBlbHNld2hlcmVcbiAqXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzRGF0ZSA9IChvYmplY3QpID0+IHtcbiAgcmV0dXJuIFRPX1NUUklORy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgdHdvIG9iamVjdHMgaGF2ZSBlcXVhbCB2YWx1ZXMgKGNoZWNrcyBkZWVwbHkpXG4gKlxuICogQHBhcmFtIHsqfSBvYmplY3QxXG4gKiBAcGFyYW0geyp9IG9iamVjdDJcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnQgY29uc3QgaXNFcXVhbCA9IChvYmplY3QxLCBvYmplY3QyKSA9PiB7XG4gIHJldHVybiBoYXNoQ29kZShvYmplY3QxKSA9PT0gaGFzaENvZGUob2JqZWN0Mik7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgb2JqZWN0IGlzIG9mIHR5cGUgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKG9iamVjdCkgPT4ge1xuICByZXR1cm4gVE9fU1RSSU5HLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB8fCB0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgb2JqZWN0IGlzIGluc3RhbmNlIG9mIENvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvbnN0cnVjdG9yXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzSW5zdGFuY2VPZiA9IChvYmplY3QsIENvbnN0cnVjdG9yKSA9PiB7XG4gIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBDb25zdHJ1Y3Rvcjtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBvYmplY3QgaXMgb2YgdHlwZSBPYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc09iamVjdCA9IChvYmplY3QpID0+IHtcbiAgcmV0dXJuIFRPX1NUUklORy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmICEhb2JqZWN0O1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIG9iamVjdCBpcyBvZiB0eXBlIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzU3RyaW5nID0gKG9iamVjdCkgPT4ge1xuICByZXR1cm4gVE9fU1RSSU5HLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuXG4vKipcbiAqIFNldCBwcm9wZXJ0eSB0byBiZSBub24tZW51bWVyYWJsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5leHBvcnQgY29uc3Qgc2V0SGlkZGVuID0gKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBTZXJpYWxpemUgb2JqZWN0IGludG8gc3RyaW5nIHZhbHVlLCB0byBiZSB1c2VkIGZvciBoYXNoaW5nXG4gKlxuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IHNlcmlhbGl6ZSA9IChvYmplY3QpID0+IHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBvYmplY3Q7XG5cbiAgbGV0IHNlcmlhbGl6ZWRDb2RlID0gJyc7XG5cbiAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChsZXQgZWxlbWVudCBpbiBvYmplY3QpIHtcbiAgICAgIHNlcmlhbGl6ZWRDb2RlICs9IGB7JHt0eXBlfToke2VsZW1lbnR9JHtzZXJpYWxpemUob2JqZWN0W2VsZW1lbnRdKX19YDtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNlcmlhbGl6ZWRDb2RlICs9IGB7JHt0eXBlfToke29iamVjdC50b1N0cmluZygpfX1gO1xuICB9IGVsc2Uge1xuICAgIHNlcmlhbGl6ZWRDb2RlICs9IGB7JHt0eXBlfToke29iamVjdH19YDtcbiAgfVxuXG4gIHJldHVybiBzZXJpYWxpemVkQ29kZS5yZXBsYWNlKC9cXHMvZywgJycpO1xufTtcblxuLyoqXG4gKiBTZXQgcHJvcGVydHkgb24gb2JqZWN0IGFzIGdldHRlciBvbmx5LCBtYWtpbmcgaXQgaW1tdXRhYmxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRSZWFkb25seSA9IChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNldCgpIHtcbiAgICAgIHRocm93RXJyb3IoYENhbm5vdCBzZXQgYSB2YWx1ZSBmb3IgJHtwcm9wZXJ0eX0sIGFzIGl0IGlzIGltbXV0YWJsZS5gKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDb25zb2xpZGF0ZWQgZXJyb3IgdGhyb3dpbmcgZnVuY3Rpb24sIG1haW5seSBmb3IgbWluaWZpY2F0aW9uIGJlbmVmaXRzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVycm9yXG4gKi9cbmV4cG9ydCBjb25zdCB0aHJvd0Vycm9yID0gKGVycm9yKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGJpbmRGdW5jdGlvbixcbiAgZmluZEluZGV4LFxuICBmb3JFYWNoT2JqZWN0LFxuICBnZXRDbG9uZSxcbiAgaGFzaENvZGUsXG4gIGlzQXJyYXksXG4gIGlzRXF1YWwsXG4gIGlzRnVuY3Rpb24sXG4gIGlzSW5zdGFuY2VPZixcbiAgaXNPYmplY3QsXG4gIGlzU3RyaW5nLFxuICBzZXRIaWRkZW4sXG4gIHNldFJlYWRvbmx5LFxuICB0aHJvd0Vycm9yXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHNyYy91dGlscy5qc1xuICoqLyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQURBO0FBQ0E7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQVBBO0FBQ0E7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSEE7QUFDQTs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBO0FBS0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFYQTtBQUNBOztBQURBO0FBQ0E7QUFhQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBekJBO0FBQ0E7Ozs7Ozs7QUFpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQWhCQTtBQUNBOzs7Ozs7O0FBd0JBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7OztBQVVBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7OztBQVVBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7O0FBU0E7QUFDQTtBQURBO0FBQ0E7Ozs7Ozs7O0FBVUE7QUFDQTtBQURBO0FBQ0E7Ozs7Ozs7QUFTQTtBQUNBO0FBREE7QUFDQTs7Ozs7OztBQVNBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBREE7QUFDQTs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFEQTtBQUdBO0FBSEE7QUFDQTtBQUtBO0FBZkE7QUFDQTs7Ozs7Ozs7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFMQTtBQUFBO0FBREE7QUFDQTs7Ozs7O0FBZUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;