/*!
 * Library: singulum
 * Description: State management sanity with minimal effort
 * Author: planttheidea
 * Version: 1.0.0
 * License: MIT
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("singulum", [], factory);
	else if(typeof exports === 'object')
		exports["singulum"] = factory();
	else
		root["singulum"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Singulum.js":
/*!*************************!*\
  !*** ./src/Singulum.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Singulum = exports.SingulumSnapshot = exports.SingulumStore = exports.SingulumActions = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar OBJECT_FREEZE = Object.freeze;\nvar isEnvProduction = (0, _utils.isProduction)();\n\n/**\n * This is a basic counter in case a namespace is not provided when creating\n * a branch\n */\nvar namespaceIncrementer = 0;\n\n/**\n *\n * @param {Singulum} singulum\n */\nvar fireWatchers = function fireWatchers(singulum) {\n  singulum.$$watchers.forEach(function (watcher) {\n    watcher(singulum.store);\n  });\n};\n\n/**\n * Actions class provided with [branchName].actions\n */\n\nvar SingulumActions = exports.SingulumActions = function () {\n  /**\n   * Create immutable and frozen object of internal actions\n   *\n   * @param {Object} actions\n   * @returns {Object}\n   */\n  function SingulumActions() {\n    var actions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, SingulumActions);\n\n    var returnValue = isEnvProduction ? {} : this;\n\n    (0, _utils.forEachObject)(actions, function (value, key) {\n      (0, _utils.setImmutable)(returnValue, key, actions[key]);\n    });\n\n    if (!isEnvProduction) {\n      OBJECT_FREEZE(returnValue);\n    }\n\n    return returnValue;\n  }\n\n  _createClass(SingulumActions, [{\n    key: 'log',\n    value: function log() {\n      if (console) {\n        // eslint-disable-next-line no-console\n        console.log((0, _utils.getMutableObject)(this));\n      }\n    }\n  }]);\n\n  return SingulumActions;\n}();\n\n/**\n * Store class provided with [branchName].store\n */\n\n\nvar SingulumStore = exports.SingulumStore = function () {\n  /**\n   * Create immutable and frozen object of store\n   * branched from it\n   *\n   * @param {Object} store\n   * @returns {Object}\n   */\n  function SingulumStore() {\n    var store = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, SingulumStore);\n\n    var returnValue = isEnvProduction ? {} : this;\n\n    (0, _utils.forEachObject)(store, function (value, key) {\n      // eslint-disable-next-line no-use-before-define\n      (0, _utils.setImmutable)(returnValue, key, (0, _utils.isInstanceOf)(value, Singulum) ? value.store : value);\n    });\n\n    if (!isEnvProduction) {\n      OBJECT_FREEZE(returnValue);\n    }\n\n    return returnValue;\n  }\n\n  _createClass(SingulumStore, [{\n    key: 'log',\n    value: function log() {\n      if (console) {\n        // eslint-disable-next-line no-console\n        console.log((0, _utils.getMutableObject)(this));\n      }\n    }\n  }]);\n\n  return SingulumStore;\n}();\n\n/**\n * If the value is a class, return a cloned version of that class including prototype,\n * else return value clone of object\n *\n * @param {*} value\n * @returns {*}\n */\n\n\nvar getFreshValueClone = function getFreshValueClone(value) {\n  var isValueInstance = (0, _utils.isClassInstance)(value);\n\n  if (isValueInstance) {\n    return Object.create(Object.getPrototypeOf(value), Object.getOwnPropertyNames(value).reduce(function (previous, current) {\n      previous[current] = Object.getOwnPropertyDescriptor(value, current);\n\n      return previous;\n    }, {}));\n  }\n\n  return (0, _utils.getClone)(value, SingulumStore);\n};\n\n/**\n * Assigns new result to store, fires listener with new SingulumStore, and returns\n * Promise with new result\n *\n * @param {Singulum} singulum\n * @param {string} key\n * @param {*} result\n * @returns {Promise}\n */\nvar updateStoreValue = function updateStoreValue(singulum, result, key) {\n  /**\n   * Apply new result value to the store, scoped if the key is provided\n   */\n  if (key) {\n    singulum.$$store[key] = result;\n  } else {\n    singulum.$$store = result;\n  }\n\n  singulum.store = new SingulumStore(singulum.$$store);\n\n  /**\n   * If there is a watcher, fire it\n   */\n  fireWatchers(singulum);\n\n  return result;\n};\n\n/**\n * Creates bound and wrapped function to store new value internally and invoke listener\n * If function is asyncronous, it waits for the promise to be resolved before firing\n *\n * @param {Singulum} singulum\n * @param {Function} fn\n * @param {string} key\n * @return {Function}\n */\nvar createWrapperFunction = function createWrapperFunction(singulum, fn, key) {\n  return (\n    /**\n     * @note must be a standard function instead of an arrow function, to allow the this binding\n     */\n    (0, _utils.bindFunction)(function () {\n      var _this = this;\n\n      var primaryArgument = key ? singulum.$$store[key] : singulum.$$store;\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var result = fn.apply(undefined, [primaryArgument].concat(args));\n\n      /**\n       * If the result is a Promise, wait for resolution and then return the data\n       */\n      if ((0, _utils.isFunction)(result.then)) {\n        return result.then(function (resultValue) {\n          return updateStoreValue(_this, resultValue, key);\n        });\n      }\n\n      /**\n       * Otherwise, wrap the return data in a native Promise and return it\n       */\n      return Promise.resolve(updateStoreValue(this, result, key));\n    }, singulum)\n  );\n};\n\n/**\n * Creates new item in the store, and creates related action with wrapper\n *\n * @param {Singulum} singulum\n * @param {Object} actions\n * @param {Object} initialValues\n */\nvar createNewSingulumLeaves = function createNewSingulumLeaves(singulum) {\n  var actions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  (0, _utils.forEachObject)(initialValues, function (initialValue, storeKey) {\n    /**\n     * Create separate clones for initialValues and store, so that references between\n     * the two do not exist\n     */\n    singulum.$$initialValues[storeKey] = initialValue;\n    singulum.$$store[storeKey] = getFreshValueClone(initialValue);\n  });\n\n  (0, _utils.forEachObject)(actions, function (action, actionKey) {\n    /**\n     * if action is a function, then it applies to the entire state\n     */\n    if ((0, _utils.isFunction)(action)) {\n      singulum.$$actions[actionKey] = createWrapperFunction(singulum, action);\n    } else if ((0, _utils.isObject)(action)) {\n      /**\n       * if action is a map of functions, it applies to a specific key on the store\n       */\n      (0, _utils.forEachObject)(action, function (actionFn, actionFnKey) {\n        singulum.$$actions[actionFnKey] = createWrapperFunction(singulum, actionFn, actionKey);\n      });\n    }\n  });\n};\n\n/**\n * Snapshot class provided with [branchName].snapshot();\n */\n\nvar SingulumSnapshot =\n/**\n * Create snapshot clone of store, optionally snapshotting deeply\n *\n * @param {SingulumStore} store\n * @param {Singulum} $$store\n * @param {boolean} snapshotBranches\n * @returns {Object}\n */\nexports.SingulumSnapshot = function SingulumSnapshot() {\n  var store = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _this2 = this;\n\n  var $$store = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var snapshotBranches = arguments[2];\n\n  _classCallCheck(this, SingulumSnapshot);\n\n  (0, _utils.forEachObject)(store, function (value, key) {\n    var $$value = $$store[key];\n\n    // eslint-disable-next-line no-use-before-define\n    if ((0, _utils.isInstanceOf)($$value, Singulum)) {\n      _this2[key] = snapshotBranches ? new SingulumSnapshot($$value.store, $$value.$$store, snapshotBranches) : $$value;\n    } else {\n      _this2[key] = (0, _utils.getClone)($$value, SingulumStore);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Creates namespaced Singulum within the object, aka make a branch\n *\n * @param {Singulum} singulum\n * @param {string} namespace\n * @param {Object} actions\n * @param {Object} initialValues\n * @returns {Object}\n */\n\n\nvar createNewSingulumNamespace = function createNewSingulumNamespace(singulum, namespace) {\n  var actions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var initialValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  /**\n   * if no namespace is provided, use the simple counter to create a unique entry\n   */\n  if (!namespace) {\n    namespace = namespaceIncrementer;\n    namespaceIncrementer++;\n  }\n\n  // eslint-disable-next-line no-use-before-define\n  (0, _utils.setReadonly)(singulum, namespace, new Singulum(actions, initialValues));\n\n  singulum.$$store[namespace] = singulum[namespace];\n  singulum.store = new SingulumStore(singulum.$$store);\n\n  return singulum[namespace];\n};\n\n/**\n * Main class\n */\n\nvar Singulum = exports.Singulum = function () {\n  /**\n   * Create singulum infrastructure, and populate leaves provided\n   *\n   * @param {Object} actions\n   * @param {Object} initialValues\n   * @returns {Singulum}\n   */\n  function Singulum() {\n    var actions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var initialValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Singulum);\n\n    (0, _utils.setHidden)(this, '$$actions', []);\n    (0, _utils.setHidden)(this, '$$initialValues', {});\n    (0, _utils.setHidden)(this, '$$watchers', []);\n    (0, _utils.setHidden)(this, '$$snapshots', {});\n    (0, _utils.setHidden)(this, '$$store', {});\n\n    createNewSingulumLeaves(this, actions, initialValues);\n\n    this.actions = isEnvProduction ? this.$$actions : new SingulumActions(this.$$actions);\n    this.store = new SingulumStore(this.$$store);\n\n    return this;\n  }\n\n  /**\n   * Create namespaced Singulum child\n   *\n   * @param {Object} actions\n   * @param {Object} initialValues\n   * @param {string} namespace\n   * @returns {Singulum}\n   */\n\n\n  _createClass(Singulum, [{\n    key: 'branch',\n    value: function branch() {\n      var actions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var initialValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var namespace = arguments[2];\n\n      /**\n       * if a namespace is provided but it isn't a string value, make it one\n       */\n      if (namespace && !(0, _utils.isString)(namespace)) {\n        namespace = namespace.toString();\n      }\n\n      return createNewSingulumNamespace(this, namespace, actions, initialValues);\n    }\n\n    /**\n     * Determine if object passed is equal in value to the branch\n     * If key is passed, performs value equality check on branch[key] only\n     *\n     * @param {*} object\n     * @param {string} key\n     * @returns {*}\n     */\n\n  }, {\n    key: 'equals',\n    value: function equals(object, key) {\n      if (key) {\n        return (0, _utils.isEqual)(this.$$store[key], object, Singulum);\n      }\n\n      return (0, _utils.isEqual)(this.$$store, object, Singulum);\n    }\n  }, {\n    key: 'hashCode',\n    value: function hashCode(key) {\n      if (key) {\n        return (0, _utils.hashCode)(this.$$store[key], Singulum);\n      }\n\n      return (0, _utils.hashCode)(this.$$store, Singulum);\n    }\n\n    /**\n     * Return singulum to its original state\n     *\n     * @param {boolean} resetBranches\n     * @returns {Singulum}\n     */\n\n  }, {\n    key: 'reset',\n    value: function reset() {\n      var _this3 = this;\n\n      var resetBranches = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      var newStore = {};\n\n      (0, _utils.forEachObject)(this.$$store, function (value, key) {\n        if ((0, _utils.isInstanceOf)(value, Singulum)) {\n          /**\n           * if snapshot value is a Singulum and you want to reset child branches, then trigger\n           * .reset() on child branch, else retain existing value\n           */\n          newStore[key] = resetBranches ? value.reset() : value;\n        } else if (!(0, _utils.isUndefined)(_this3.$$initialValues[key])) {\n          /**\n           * If the value is a non-Singulum value and it existed in initialValues, assign its\n           * initialValue to the store\n           */\n          newStore[key] = _this3.$$initialValues[key];\n        }\n      });\n\n      this.$$store = newStore;\n      this.store = new SingulumStore(this.$$store);\n\n      /**\n       * If there is a watcher, fire it\n       */\n      fireWatchers(this);\n\n      return this;\n    }\n\n    /**\n     * Restore values in store based on snapshot, optionally restored deeply\n     *\n     * @param {SingulumSnapshot} snapshot\n     * @param {boolean} restoreBranches\n     * @returns {Singulum}\n     */\n\n  }, {\n    key: 'restore',\n    value: function restore(snapshot) {\n      var _this4 = this;\n\n      var restoreBranches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      /**\n       * Make sure snapshot passed is a SingulumSnapshot\n       */\n      if (!(0, _utils.isInstanceOf)(snapshot, SingulumSnapshot)) {\n        (0, _utils.throwError)('Snapshot used in restore method must be a SingulumSnapshot.');\n      }\n\n      (0, _utils.forEachObject)(snapshot, function (value, key) {\n        if (!(0, _utils.isInstanceOf)(value, Singulum)) {\n          if ((0, _utils.isInstanceOf)(value, SingulumSnapshot)) {\n            /**\n             * if the snapshot value is a SingulumSnapshot and you want to reset\n             * child branches, then trigger restore on the child branch passing value\n             * as branch's snapshot\n             */\n            _this4.$$store[key] = restoreBranches ? _this4.$$store[key].restore(value, restoreBranches) : value;\n          } else if (!(0, _utils.isInstanceOf)(value, SingulumStore)) {\n            /**\n             * If the snapshot value is not a Singulum, re-apply it to the store\n             */\n            _this4.$$store[key] = (0, _utils.isInstanceOf)(value, Singulum) ? value.store : value;\n          }\n        }\n      });\n\n      this.store = new SingulumStore(this.$$store);\n\n      /**\n       * If there is a watcher, fire it\n       */\n      fireWatchers(this);\n\n      return this;\n    }\n\n    /**\n     * Create snapshot of current store state, optionally snapshot deeply\n     *\n     * @param {boolean} snapshotBranches\n     * @returns {SingulumSnapshot}\n     */\n\n  }, {\n    key: 'snapshot',\n    value: function snapshot() {\n      var snapshotBranches = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      return new SingulumSnapshot(this.store, this.$$store, snapshotBranches);\n    }\n\n    /**\n     * Clear out callback bound to $$watchers\n     *\n     * @returns {Singulum}\n     */\n\n  }, {\n    key: 'unwatch',\n    value: function unwatch(callback) {\n      var watcherIndex = (0, _utils.findIndex)(this.$$watchers, function (watcher) {\n        return watcher === callback;\n      });\n\n      this.$$watchers = [].concat(_toConsumableArray(this.$$watchers.slice(0, watcherIndex)), _toConsumableArray(this.$$watchers.slice(watcherIndex + 1, this.$$watchers.length)));\n\n      return this;\n    }\n\n    /**\n     * Add callback to $$watchers, to be fired whenever store updates\n     *\n     * @param {Function} callback\n     * @returns {Singulum}\n     */\n\n  }, {\n    key: 'watch',\n    value: function watch(callback) {\n      /**\n       * Make sure callback is actually a function before setting it\n       */\n      if ((0, _utils.isFunction)(callback)) {\n        this.$$watchers = [].concat(_toConsumableArray(this.$$watchers), [callback]);\n      }\n\n      return this;\n    }\n  }]);\n\n  return Singulum;\n}();\n\nexports.default = Singulum;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU2luZ3VsdW0uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaW5ndWx1bS9zcmMvU2luZ3VsdW0uanM/OWY2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBiaW5kRnVuY3Rpb24sXG4gIGZpbmRJbmRleCxcbiAgZm9yRWFjaE9iamVjdCxcbiAgZ2V0Q2xvbmUsXG4gIGdldE11dGFibGVPYmplY3QsXG4gIGhhc2hDb2RlLFxuICBpc0NsYXNzSW5zdGFuY2UsXG4gIGlzRXF1YWwsXG4gIGlzRnVuY3Rpb24sXG4gIGlzSW5zdGFuY2VPZixcbiAgaXNPYmplY3QsXG4gIGlzUHJvZHVjdGlvbixcbiAgaXNTdHJpbmcsXG4gIGlzVW5kZWZpbmVkLFxuICBzZXRIaWRkZW4sXG4gIHNldEltbXV0YWJsZSxcbiAgc2V0UmVhZG9ubHksXG4gIHRocm93RXJyb3IsXG59IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBPQkpFQ1RfRlJFRVpFID0gT2JqZWN0LmZyZWV6ZTtcbmNvbnN0IGlzRW52UHJvZHVjdGlvbiA9IGlzUHJvZHVjdGlvbigpO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBiYXNpYyBjb3VudGVyIGluIGNhc2UgYSBuYW1lc3BhY2UgaXMgbm90IHByb3ZpZGVkIHdoZW4gY3JlYXRpbmdcbiAqIGEgYnJhbmNoXG4gKi9cbmxldCBuYW1lc3BhY2VJbmNyZW1lbnRlciA9IDA7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7U2luZ3VsdW19IHNpbmd1bHVtXG4gKi9cbmNvbnN0IGZpcmVXYXRjaGVycyA9IChzaW5ndWx1bSkgPT4ge1xuICBzaW5ndWx1bS4kJHdhdGNoZXJzLmZvckVhY2goKHdhdGNoZXIpID0+IHtcbiAgICB3YXRjaGVyKHNpbmd1bHVtLnN0b3JlKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFjdGlvbnMgY2xhc3MgcHJvdmlkZWQgd2l0aCBbYnJhbmNoTmFtZV0uYWN0aW9uc1xuICovXG5leHBvcnQgY2xhc3MgU2luZ3VsdW1BY3Rpb25zIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBpbW11dGFibGUgYW5kIGZyb3plbiBvYmplY3Qgb2YgaW50ZXJuYWwgYWN0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uc1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgY29uc3RydWN0b3IoYWN0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHJldHVyblZhbHVlID0gaXNFbnZQcm9kdWN0aW9uID8ge30gOiB0aGlzO1xuXG4gICAgZm9yRWFjaE9iamVjdChhY3Rpb25zLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgc2V0SW1tdXRhYmxlKHJldHVyblZhbHVlLCBrZXksIGFjdGlvbnNba2V5XSk7XG4gICAgfSk7XG5cbiAgICBpZiAoIWlzRW52UHJvZHVjdGlvbikge1xuICAgICAgT0JKRUNUX0ZSRUVaRShyZXR1cm5WYWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG5cbiAgbG9nKCkge1xuICAgIGlmIChjb25zb2xlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5sb2coZ2V0TXV0YWJsZU9iamVjdCh0aGlzKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU3RvcmUgY2xhc3MgcHJvdmlkZWQgd2l0aCBbYnJhbmNoTmFtZV0uc3RvcmVcbiAqL1xuZXhwb3J0IGNsYXNzIFNpbmd1bHVtU3RvcmUge1xuICAvKipcbiAgICogQ3JlYXRlIGltbXV0YWJsZSBhbmQgZnJvemVuIG9iamVjdCBvZiBzdG9yZVxuICAgKiBicmFuY2hlZCBmcm9tIGl0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdG9yZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3RvcmUgPSB7fSkge1xuICAgIGxldCByZXR1cm5WYWx1ZSA9IGlzRW52UHJvZHVjdGlvbiA/IHt9IDogdGhpcztcblxuICAgIGZvckVhY2hPYmplY3Qoc3RvcmUsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgIHNldEltbXV0YWJsZShyZXR1cm5WYWx1ZSwga2V5LCBpc0luc3RhbmNlT2YodmFsdWUsIFNpbmd1bHVtKSA/IHZhbHVlLnN0b3JlIDogdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFpc0VudlByb2R1Y3Rpb24pIHtcbiAgICAgIE9CSkVDVF9GUkVFWkUocmV0dXJuVmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuXG4gIGxvZygpIHtcbiAgICBpZiAoY29uc29sZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUubG9nKGdldE11dGFibGVPYmplY3QodGhpcykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIElmIHRoZSB2YWx1ZSBpcyBhIGNsYXNzLCByZXR1cm4gYSBjbG9uZWQgdmVyc2lvbiBvZiB0aGF0IGNsYXNzIGluY2x1ZGluZyBwcm90b3R5cGUsXG4gKiBlbHNlIHJldHVybiB2YWx1ZSBjbG9uZSBvZiBvYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuY29uc3QgZ2V0RnJlc2hWYWx1ZUNsb25lID0gKHZhbHVlKSA9PiB7XG4gIGNvbnN0IGlzVmFsdWVJbnN0YW5jZSA9IGlzQ2xhc3NJbnN0YW5jZSh2YWx1ZSk7XG5cbiAgaWYgKGlzVmFsdWVJbnN0YW5jZSkge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKFxuICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSxcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiB7XG4gICAgICAgIHByZXZpb3VzW2N1cnJlbnRdID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwgY3VycmVudCk7XG5cbiAgICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgICAgfSwge30pXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBnZXRDbG9uZSh2YWx1ZSwgU2luZ3VsdW1TdG9yZSk7XG59O1xuXG4vKipcbiAqIEFzc2lnbnMgbmV3IHJlc3VsdCB0byBzdG9yZSwgZmlyZXMgbGlzdGVuZXIgd2l0aCBuZXcgU2luZ3VsdW1TdG9yZSwgYW5kIHJldHVybnNcbiAqIFByb21pc2Ugd2l0aCBuZXcgcmVzdWx0XG4gKlxuICogQHBhcmFtIHtTaW5ndWx1bX0gc2luZ3VsdW1cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gcmVzdWx0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuY29uc3QgdXBkYXRlU3RvcmVWYWx1ZSA9IChzaW5ndWx1bSwgcmVzdWx0LCBrZXkpID0+IHtcbiAgLyoqXG4gICAqIEFwcGx5IG5ldyByZXN1bHQgdmFsdWUgdG8gdGhlIHN0b3JlLCBzY29wZWQgaWYgdGhlIGtleSBpcyBwcm92aWRlZFxuICAgKi9cbiAgaWYgKGtleSkge1xuICAgIHNpbmd1bHVtLiQkc3RvcmVba2V5XSA9IHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICBzaW5ndWx1bS4kJHN0b3JlID0gcmVzdWx0O1xuICB9XG5cbiAgc2luZ3VsdW0uc3RvcmUgPSBuZXcgU2luZ3VsdW1TdG9yZShzaW5ndWx1bS4kJHN0b3JlKTtcblxuICAvKipcbiAgICogSWYgdGhlcmUgaXMgYSB3YXRjaGVyLCBmaXJlIGl0XG4gICAqL1xuICBmaXJlV2F0Y2hlcnMoc2luZ3VsdW0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYm91bmQgYW5kIHdyYXBwZWQgZnVuY3Rpb24gdG8gc3RvcmUgbmV3IHZhbHVlIGludGVybmFsbHkgYW5kIGludm9rZSBsaXN0ZW5lclxuICogSWYgZnVuY3Rpb24gaXMgYXN5bmNyb25vdXMsIGl0IHdhaXRzIGZvciB0aGUgcHJvbWlzZSB0byBiZSByZXNvbHZlZCBiZWZvcmUgZmlyaW5nXG4gKlxuICogQHBhcmFtIHtTaW5ndWx1bX0gc2luZ3VsdW1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuY29uc3QgY3JlYXRlV3JhcHBlckZ1bmN0aW9uID0gKHNpbmd1bHVtLCBmbiwga2V5KSA9PlxuICAvKipcbiAgICogQG5vdGUgbXVzdCBiZSBhIHN0YW5kYXJkIGZ1bmN0aW9uIGluc3RlYWQgb2YgYW4gYXJyb3cgZnVuY3Rpb24sIHRvIGFsbG93IHRoZSB0aGlzIGJpbmRpbmdcbiAgICovXG4gIGJpbmRGdW5jdGlvbihmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgcHJpbWFyeUFyZ3VtZW50ID0ga2V5ID8gc2luZ3VsdW0uJCRzdG9yZVtrZXldIDogc2luZ3VsdW0uJCRzdG9yZTtcbiAgICBjb25zdCByZXN1bHQgPSBmbihwcmltYXJ5QXJndW1lbnQsIC4uLmFyZ3MpO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIHJlc3VsdCBpcyBhIFByb21pc2UsIHdhaXQgZm9yIHJlc29sdXRpb24gYW5kIHRoZW4gcmV0dXJuIHRoZSBkYXRhXG4gICAgICovXG4gICAgaWYgKGlzRnVuY3Rpb24ocmVzdWx0LnRoZW4pKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdFZhbHVlKSA9PiB1cGRhdGVTdG9yZVZhbHVlKHRoaXMsIHJlc3VsdFZhbHVlLCBrZXkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdGhlcndpc2UsIHdyYXAgdGhlIHJldHVybiBkYXRhIGluIGEgbmF0aXZlIFByb21pc2UgYW5kIHJldHVybiBpdFxuICAgICAqL1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodXBkYXRlU3RvcmVWYWx1ZSh0aGlzLCByZXN1bHQsIGtleSkpO1xuICB9LCBzaW5ndWx1bSk7XG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaXRlbSBpbiB0aGUgc3RvcmUsIGFuZCBjcmVhdGVzIHJlbGF0ZWQgYWN0aW9uIHdpdGggd3JhcHBlclxuICpcbiAqIEBwYXJhbSB7U2luZ3VsdW19IHNpbmd1bHVtXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGluaXRpYWxWYWx1ZXNcbiAqL1xuY29uc3QgY3JlYXRlTmV3U2luZ3VsdW1MZWF2ZXMgPSAoc2luZ3VsdW0sIGFjdGlvbnMgPSB7fSwgaW5pdGlhbFZhbHVlcyA9IHt9KSA9PiB7XG4gIGZvckVhY2hPYmplY3QoaW5pdGlhbFZhbHVlcywgKGluaXRpYWxWYWx1ZSwgc3RvcmVLZXkpID0+IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgc2VwYXJhdGUgY2xvbmVzIGZvciBpbml0aWFsVmFsdWVzIGFuZCBzdG9yZSwgc28gdGhhdCByZWZlcmVuY2VzIGJldHdlZW5cbiAgICAgKiB0aGUgdHdvIGRvIG5vdCBleGlzdFxuICAgICAqL1xuICAgIHNpbmd1bHVtLiQkaW5pdGlhbFZhbHVlc1tzdG9yZUtleV0gPSBpbml0aWFsVmFsdWU7XG4gICAgc2luZ3VsdW0uJCRzdG9yZVtzdG9yZUtleV0gPSBnZXRGcmVzaFZhbHVlQ2xvbmUoaW5pdGlhbFZhbHVlKTtcbiAgfSk7XG5cbiAgZm9yRWFjaE9iamVjdChhY3Rpb25zLCAoYWN0aW9uLCBhY3Rpb25LZXkpID0+IHtcbiAgICAvKipcbiAgICAgKiBpZiBhY3Rpb24gaXMgYSBmdW5jdGlvbiwgdGhlbiBpdCBhcHBsaWVzIHRvIHRoZSBlbnRpcmUgc3RhdGVcbiAgICAgKi9cbiAgICBpZiAoaXNGdW5jdGlvbihhY3Rpb24pKSB7XG4gICAgICBzaW5ndWx1bS4kJGFjdGlvbnNbYWN0aW9uS2V5XSA9IGNyZWF0ZVdyYXBwZXJGdW5jdGlvbihzaW5ndWx1bSwgYWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGFjdGlvbikpIHtcbiAgICAgIC8qKlxuICAgICAgICogaWYgYWN0aW9uIGlzIGEgbWFwIG9mIGZ1bmN0aW9ucywgaXQgYXBwbGllcyB0byBhIHNwZWNpZmljIGtleSBvbiB0aGUgc3RvcmVcbiAgICAgICAqL1xuICAgICAgZm9yRWFjaE9iamVjdChhY3Rpb24sIChhY3Rpb25GbiwgYWN0aW9uRm5LZXkpID0+IHtcbiAgICAgICAgc2luZ3VsdW0uJCRhY3Rpb25zW2FjdGlvbkZuS2V5XSA9IGNyZWF0ZVdyYXBwZXJGdW5jdGlvbihzaW5ndWx1bSwgYWN0aW9uRm4sIGFjdGlvbktleSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTbmFwc2hvdCBjbGFzcyBwcm92aWRlZCB3aXRoIFticmFuY2hOYW1lXS5zbmFwc2hvdCgpO1xuICovXG5leHBvcnQgY2xhc3MgU2luZ3VsdW1TbmFwc2hvdCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgc25hcHNob3QgY2xvbmUgb2Ygc3RvcmUsIG9wdGlvbmFsbHkgc25hcHNob3R0aW5nIGRlZXBseVxuICAgKlxuICAgKiBAcGFyYW0ge1Npbmd1bHVtU3RvcmV9IHN0b3JlXG4gICAqIEBwYXJhbSB7U2luZ3VsdW19ICQkc3RvcmVcbiAgICogQHBhcmFtIHtib29sZWFufSBzbmFwc2hvdEJyYW5jaGVzXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihzdG9yZSA9IHt9LCAkJHN0b3JlID0ge30sIHNuYXBzaG90QnJhbmNoZXMpIHtcbiAgICBmb3JFYWNoT2JqZWN0KHN0b3JlLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgY29uc3QgJCR2YWx1ZSA9ICQkc3RvcmVba2V5XTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICBpZiAoaXNJbnN0YW5jZU9mKCQkdmFsdWUsIFNpbmd1bHVtKSkge1xuICAgICAgICB0aGlzW2tleV0gPSBzbmFwc2hvdEJyYW5jaGVzID8gbmV3IFNpbmd1bHVtU25hcHNob3QoJCR2YWx1ZS5zdG9yZSwgJCR2YWx1ZS4kJHN0b3JlLCBzbmFwc2hvdEJyYW5jaGVzKSA6ICQkdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW2tleV0gPSBnZXRDbG9uZSgkJHZhbHVlLCBTaW5ndWx1bVN0b3JlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBuYW1lc3BhY2VkIFNpbmd1bHVtIHdpdGhpbiB0aGUgb2JqZWN0LCBha2EgbWFrZSBhIGJyYW5jaFxuICpcbiAqIEBwYXJhbSB7U2luZ3VsdW19IHNpbmd1bHVtXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGluaXRpYWxWYWx1ZXNcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmNvbnN0IGNyZWF0ZU5ld1Npbmd1bHVtTmFtZXNwYWNlID0gKHNpbmd1bHVtLCBuYW1lc3BhY2UsIGFjdGlvbnMgPSB7fSwgaW5pdGlhbFZhbHVlcyA9IHt9KSA9PiB7XG4gIC8qKlxuICAgKiBpZiBubyBuYW1lc3BhY2UgaXMgcHJvdmlkZWQsIHVzZSB0aGUgc2ltcGxlIGNvdW50ZXIgdG8gY3JlYXRlIGEgdW5pcXVlIGVudHJ5XG4gICAqL1xuICBpZiAoIW5hbWVzcGFjZSkge1xuICAgIG5hbWVzcGFjZSA9IG5hbWVzcGFjZUluY3JlbWVudGVyO1xuICAgIG5hbWVzcGFjZUluY3JlbWVudGVyKys7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgc2V0UmVhZG9ubHkoc2luZ3VsdW0sIG5hbWVzcGFjZSwgbmV3IFNpbmd1bHVtKGFjdGlvbnMsIGluaXRpYWxWYWx1ZXMpKTtcblxuICBzaW5ndWx1bS4kJHN0b3JlW25hbWVzcGFjZV0gPSBzaW5ndWx1bVtuYW1lc3BhY2VdO1xuICBzaW5ndWx1bS5zdG9yZSA9IG5ldyBTaW5ndWx1bVN0b3JlKHNpbmd1bHVtLiQkc3RvcmUpO1xuXG4gIHJldHVybiBzaW5ndWx1bVtuYW1lc3BhY2VdO1xufTtcblxuLyoqXG4gKiBNYWluIGNsYXNzXG4gKi9cbmV4cG9ydCBjbGFzcyBTaW5ndWx1bSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgc2luZ3VsdW0gaW5mcmFzdHJ1Y3R1cmUsIGFuZCBwb3B1bGF0ZSBsZWF2ZXMgcHJvdmlkZWRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGluaXRpYWxWYWx1ZXNcbiAgICogQHJldHVybnMge1Npbmd1bHVtfVxuICAgKi9cbiAgY29uc3RydWN0b3IoYWN0aW9ucyA9IHt9LCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgICBzZXRIaWRkZW4odGhpcywgJyQkYWN0aW9ucycsIFtdKTtcbiAgICBzZXRIaWRkZW4odGhpcywgJyQkaW5pdGlhbFZhbHVlcycsIHt9KTtcbiAgICBzZXRIaWRkZW4odGhpcywgJyQkd2F0Y2hlcnMnLCBbXSk7XG4gICAgc2V0SGlkZGVuKHRoaXMsICckJHNuYXBzaG90cycsIHt9KTtcbiAgICBzZXRIaWRkZW4odGhpcywgJyQkc3RvcmUnLCB7fSk7XG5cbiAgICBjcmVhdGVOZXdTaW5ndWx1bUxlYXZlcyh0aGlzLCBhY3Rpb25zLCBpbml0aWFsVmFsdWVzKTtcblxuICAgIHRoaXMuYWN0aW9ucyA9IGlzRW52UHJvZHVjdGlvbiA/IHRoaXMuJCRhY3Rpb25zIDogbmV3IFNpbmd1bHVtQWN0aW9ucyh0aGlzLiQkYWN0aW9ucyk7XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBTaW5ndWx1bVN0b3JlKHRoaXMuJCRzdG9yZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgbmFtZXNwYWNlZCBTaW5ndWx1bSBjaGlsZFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gaW5pdGlhbFZhbHVlc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlXG4gICAqIEByZXR1cm5zIHtTaW5ndWx1bX1cbiAgICovXG4gIGJyYW5jaChhY3Rpb25zID0ge30sIGluaXRpYWxWYWx1ZXMgPSB7fSwgbmFtZXNwYWNlKSB7XG4gICAgLyoqXG4gICAgICogaWYgYSBuYW1lc3BhY2UgaXMgcHJvdmlkZWQgYnV0IGl0IGlzbid0IGEgc3RyaW5nIHZhbHVlLCBtYWtlIGl0IG9uZVxuICAgICAqL1xuICAgIGlmIChuYW1lc3BhY2UgJiYgIWlzU3RyaW5nKG5hbWVzcGFjZSkpIHtcbiAgICAgIG5hbWVzcGFjZSA9IG5hbWVzcGFjZS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVOZXdTaW5ndWx1bU5hbWVzcGFjZSh0aGlzLCBuYW1lc3BhY2UsIGFjdGlvbnMsIGluaXRpYWxWYWx1ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBvYmplY3QgcGFzc2VkIGlzIGVxdWFsIGluIHZhbHVlIHRvIHRoZSBicmFuY2hcbiAgICogSWYga2V5IGlzIHBhc3NlZCwgcGVyZm9ybXMgdmFsdWUgZXF1YWxpdHkgY2hlY2sgb24gYnJhbmNoW2tleV0gb25seVxuICAgKlxuICAgKiBAcGFyYW0geyp9IG9iamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZXF1YWxzKG9iamVjdCwga2V5KSB7XG4gICAgaWYgKGtleSkge1xuICAgICAgcmV0dXJuIGlzRXF1YWwodGhpcy4kJHN0b3JlW2tleV0sIG9iamVjdCwgU2luZ3VsdW0pO1xuICAgIH1cblxuICAgIHJldHVybiBpc0VxdWFsKHRoaXMuJCRzdG9yZSwgb2JqZWN0LCBTaW5ndWx1bSk7XG4gIH1cblxuICBoYXNoQ29kZShrZXkpIHtcbiAgICBpZiAoa2V5KSB7XG4gICAgICByZXR1cm4gaGFzaENvZGUodGhpcy4kJHN0b3JlW2tleV0sIFNpbmd1bHVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaENvZGUodGhpcy4kJHN0b3JlLCBTaW5ndWx1bSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHNpbmd1bHVtIHRvIGl0cyBvcmlnaW5hbCBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc2V0QnJhbmNoZXNcbiAgICogQHJldHVybnMge1Npbmd1bHVtfVxuICAgKi9cbiAgcmVzZXQocmVzZXRCcmFuY2hlcyA9IGZhbHNlKSB7XG4gICAgbGV0IG5ld1N0b3JlID0ge307XG5cbiAgICBmb3JFYWNoT2JqZWN0KHRoaXMuJCRzdG9yZSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGlmIChpc0luc3RhbmNlT2YodmFsdWUsIFNpbmd1bHVtKSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogaWYgc25hcHNob3QgdmFsdWUgaXMgYSBTaW5ndWx1bSBhbmQgeW91IHdhbnQgdG8gcmVzZXQgY2hpbGQgYnJhbmNoZXMsIHRoZW4gdHJpZ2dlclxuICAgICAgICAgKiAucmVzZXQoKSBvbiBjaGlsZCBicmFuY2gsIGVsc2UgcmV0YWluIGV4aXN0aW5nIHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBuZXdTdG9yZVtrZXldID0gcmVzZXRCcmFuY2hlcyA/IHZhbHVlLnJlc2V0KCkgOiB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuJCRpbml0aWFsVmFsdWVzW2tleV0pKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgdmFsdWUgaXMgYSBub24tU2luZ3VsdW0gdmFsdWUgYW5kIGl0IGV4aXN0ZWQgaW4gaW5pdGlhbFZhbHVlcywgYXNzaWduIGl0c1xuICAgICAgICAgKiBpbml0aWFsVmFsdWUgdG8gdGhlIHN0b3JlXG4gICAgICAgICAqL1xuICAgICAgICBuZXdTdG9yZVtrZXldID0gdGhpcy4kJGluaXRpYWxWYWx1ZXNba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuJCRzdG9yZSA9IG5ld1N0b3JlO1xuICAgIHRoaXMuc3RvcmUgPSBuZXcgU2luZ3VsdW1TdG9yZSh0aGlzLiQkc3RvcmUpO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlcmUgaXMgYSB3YXRjaGVyLCBmaXJlIGl0XG4gICAgICovXG4gICAgZmlyZVdhdGNoZXJzKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZSB2YWx1ZXMgaW4gc3RvcmUgYmFzZWQgb24gc25hcHNob3QsIG9wdGlvbmFsbHkgcmVzdG9yZWQgZGVlcGx5XG4gICAqXG4gICAqIEBwYXJhbSB7U2luZ3VsdW1TbmFwc2hvdH0gc25hcHNob3RcbiAgICogQHBhcmFtIHtib29sZWFufSByZXN0b3JlQnJhbmNoZXNcbiAgICogQHJldHVybnMge1Npbmd1bHVtfVxuICAgKi9cbiAgcmVzdG9yZShzbmFwc2hvdCwgcmVzdG9yZUJyYW5jaGVzID0gZmFsc2UpIHtcbiAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgc25hcHNob3QgcGFzc2VkIGlzIGEgU2luZ3VsdW1TbmFwc2hvdFxuICAgICAqL1xuICAgIGlmICghaXNJbnN0YW5jZU9mKHNuYXBzaG90LCBTaW5ndWx1bVNuYXBzaG90KSkge1xuICAgICAgdGhyb3dFcnJvcignU25hcHNob3QgdXNlZCBpbiByZXN0b3JlIG1ldGhvZCBtdXN0IGJlIGEgU2luZ3VsdW1TbmFwc2hvdC4nKTtcbiAgICB9XG5cbiAgICBmb3JFYWNoT2JqZWN0KHNuYXBzaG90LCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgaWYgKCFpc0luc3RhbmNlT2YodmFsdWUsIFNpbmd1bHVtKSkge1xuICAgICAgICBpZiAoaXNJbnN0YW5jZU9mKHZhbHVlLCBTaW5ndWx1bVNuYXBzaG90KSkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIGlmIHRoZSBzbmFwc2hvdCB2YWx1ZSBpcyBhIFNpbmd1bHVtU25hcHNob3QgYW5kIHlvdSB3YW50IHRvIHJlc2V0XG4gICAgICAgICAgICogY2hpbGQgYnJhbmNoZXMsIHRoZW4gdHJpZ2dlciByZXN0b3JlIG9uIHRoZSBjaGlsZCBicmFuY2ggcGFzc2luZyB2YWx1ZVxuICAgICAgICAgICAqIGFzIGJyYW5jaCdzIHNuYXBzaG90XG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy4kJHN0b3JlW2tleV0gPSByZXN0b3JlQnJhbmNoZXMgPyB0aGlzLiQkc3RvcmVba2V5XS5yZXN0b3JlKHZhbHVlLCByZXN0b3JlQnJhbmNoZXMpIDogdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzSW5zdGFuY2VPZih2YWx1ZSwgU2luZ3VsdW1TdG9yZSkpIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBJZiB0aGUgc25hcHNob3QgdmFsdWUgaXMgbm90IGEgU2luZ3VsdW0sIHJlLWFwcGx5IGl0IHRvIHRoZSBzdG9yZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMuJCRzdG9yZVtrZXldID0gaXNJbnN0YW5jZU9mKHZhbHVlLCBTaW5ndWx1bSkgPyB2YWx1ZS5zdG9yZSA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnN0b3JlID0gbmV3IFNpbmd1bHVtU3RvcmUodGhpcy4kJHN0b3JlKTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZXJlIGlzIGEgd2F0Y2hlciwgZmlyZSBpdFxuICAgICAqL1xuICAgIGZpcmVXYXRjaGVycyh0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBzbmFwc2hvdCBvZiBjdXJyZW50IHN0b3JlIHN0YXRlLCBvcHRpb25hbGx5IHNuYXBzaG90IGRlZXBseVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNuYXBzaG90QnJhbmNoZXNcbiAgICogQHJldHVybnMge1Npbmd1bHVtU25hcHNob3R9XG4gICAqL1xuICBzbmFwc2hvdChzbmFwc2hvdEJyYW5jaGVzID0gZmFsc2UpIHtcbiAgICByZXR1cm4gbmV3IFNpbmd1bHVtU25hcHNob3QodGhpcy5zdG9yZSwgdGhpcy4kJHN0b3JlLCBzbmFwc2hvdEJyYW5jaGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBvdXQgY2FsbGJhY2sgYm91bmQgdG8gJCR3YXRjaGVyc1xuICAgKlxuICAgKiBAcmV0dXJucyB7U2luZ3VsdW19XG4gICAqL1xuICB1bndhdGNoKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgd2F0Y2hlckluZGV4ID0gZmluZEluZGV4KHRoaXMuJCR3YXRjaGVycywgKHdhdGNoZXIpID0+IHdhdGNoZXIgPT09IGNhbGxiYWNrKTtcblxuICAgIHRoaXMuJCR3YXRjaGVycyA9IFtcbiAgICAgIC4uLnRoaXMuJCR3YXRjaGVycy5zbGljZSgwLCB3YXRjaGVySW5kZXgpLFxuICAgICAgLi4udGhpcy4kJHdhdGNoZXJzLnNsaWNlKHdhdGNoZXJJbmRleCArIDEsIHRoaXMuJCR3YXRjaGVycy5sZW5ndGgpLFxuICAgIF07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2sgdG8gJCR3YXRjaGVycywgdG8gYmUgZmlyZWQgd2hlbmV2ZXIgc3RvcmUgdXBkYXRlc1xuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7U2luZ3VsdW19XG4gICAqL1xuICB3YXRjaChjYWxsYmFjaykge1xuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VyZSBjYWxsYmFjayBpcyBhY3R1YWxseSBhIGZ1bmN0aW9uIGJlZm9yZSBzZXR0aW5nIGl0XG4gICAgICovXG4gICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICB0aGlzLiQkd2F0Y2hlcnMgPSBbLi4udGhpcy4kJHdhdGNoZXJzLCBjYWxsYmFja107XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2luZ3VsdW07XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7Ozs7O0FBb0JBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFHQTtBQUNBOzs7Ozs7QUFNQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7Ozs7O0FBR0E7QUFDQTs7Ozs7OztBQU9BO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUdBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUFBO0FBQ0E7OztBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFGQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFuQkE7QUFBQTtBQUNBO0FBb0JBOzs7Ozs7O0FBT0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUdBO0FBQ0E7Ozs7Ozs7O0FBREE7QUFTQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBU0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBR0E7QUFDQTs7Ozs7OztBQU9BO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUdBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Singulum.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Singulum = __webpack_require__(/*! ./Singulum */ \"./src/Singulum.js\");\n\nvar _Singulum2 = _interopRequireDefault(_Singulum);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = new _Singulum2.default();\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaW5ndWx1bS9zcmMvaW5kZXguanM/MTJkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU2luZ3VsdW0gZnJvbSAnLi9TaW5ndWx1bSc7XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBTaW5ndWx1bSgpO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOzs7OztBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.getMutableObject = getMutableObject;\nvar DEFINE_PROPERTY = Object.defineProperty;\nvar GET_OWN_PROPERTY_NAMES = Object.getOwnPropertyNames;\nvar TO_STRING = Object.prototype.toString;\n\n/**\n * Determines if object is of type Array\n *\n * @param {*} object\n * @returns {boolean}\n */\nvar isArray = exports.isArray = function isArray(object) {\n  return TO_STRING.call(object) === '[object Array]';\n};\n\n/**\n * Determines if object is of type Object\n *\n * @param {*} object\n * @returns {boolean}\n */\nvar isObject = exports.isObject = function isObject(object) {\n  return TO_STRING.call(object) === '[object Object]' && !!object;\n};\n\n/**\n * Determines if object is an instance of a class\n *\n * @param {*} object\n * @returns {boolean}\n */\nvar isClassInstance = exports.isClassInstance = function isClassInstance(object) {\n  return isObject(object) && Object.getPrototypeOf(object).constructor !== Object.prototype.constructor;\n};\n\n/**\n * Determines if object is of type Date\n * Not exported because not used elsewhere\n *\n * @param {*} object\n * @returns {boolean}\n */\nvar isDate = exports.isDate = function isDate(object) {\n  return TO_STRING.call(object) === '[object Date]';\n};\n\n/**\n * Determines if object is of type Function\n *\n * @param {*} object\n * @returns {boolean}\n */\nvar isFunction = exports.isFunction = function isFunction(object) {\n  return TO_STRING.call(object) === '[object Function]' || typeof object === 'function';\n};\n\n/**\n * Determine if object is instance of Constructor\n *\n * @param {*} object\n * @param {Function} Constructor\n * @returns {boolean}\n */\nvar isInstanceOf = exports.isInstanceOf = function isInstanceOf(object, Constructor) {\n  return object instanceof Constructor;\n};\n\n/**\n * Determines if we are in production or not, based on NODE_ENV\n *\n * @returns {boolean}\n */\nvar isProduction = exports.isProduction = function isProduction() {\n  return \"development\" === 'production';\n};\n\n/**\n * Determines if object is of type String\n *\n * @param {*} object\n * @returns {boolean}\n */\nvar isString = exports.isString = function isString(object) {\n  return TO_STRING.call(object) === '[object String]';\n};\n\n/**\n * Determines if object is undefined\n *\n * @param {*} object\n * @returns {boolean}\n */\nvar isUndefined = exports.isUndefined = function isUndefined(object) {\n  return object === void 0;\n};\n\n/**\n * Binds function to thisArg\n *\n * @param {Function} fn\n * @param {Object} thisArg\n * @returns {Function}\n */\nvar bindFunction = exports.bindFunction = function bindFunction(fn, thisArg) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return fn.apply(thisArg, args);\n  };\n};\n\n/**\n * Finds the index in the array where the callback returns a truthy value\n *\n * @param {Array} array\n * @param {Function} callback\n * @returns {number}\n */\nvar findIndex = exports.findIndex = function findIndex(array, callback) {\n  for (var index = 0, length = array.length; index < length; index++) {\n    if (callback(array[index], index, array)) {\n      return index;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Provided as faster alternative for native .forEach\n *\n * @param {Object} object\n * @param {Function} fn\n */\nvar forEachObject = exports.forEachObject = function forEachObject(object, fn) {\n  var keysArray = Object.keys(object);\n\n  for (var index = 0, length = keysArray.length; index < length; index++) {\n    var key = keysArray[index];\n\n    fn(object[key], key, object);\n  }\n};\n\n/**\n * Returns clone of Singulum object with metadata stripped and child\n * stores with SingulumStore class applied\n *\n * @param {*} object\n * @param {SingulumStore} SingulumStore\n * @returns {*}\n */\nvar getClone = exports.getClone = function getClone(object, SingulumStore) {\n  if (isArray(object)) {\n    return object.map(function (item) {\n      return getClone(item, SingulumStore);\n    });\n  }\n\n  if (isObject(object)) {\n    var cloneObject = {};\n\n    forEachObject(object, function (value, key) {\n      cloneObject[key] = getClone(value, SingulumStore);\n    });\n\n    if (isInstanceOf(object, SingulumStore)) {\n      cloneObject = new SingulumStore(cloneObject);\n    }\n\n    return cloneObject;\n  }\n\n  if (isDate(object)) {\n    return new Date(object.valueOf());\n  }\n\n  return object;\n};\n\nvar setMutableProperty = function setMutableProperty(object, property, targetObject) {\n  var descriptor = Object.getOwnPropertyDescriptor(object, property) || {};\n\n  var value = object[property];\n\n  if (isArray(value) || isObject(value)) {\n    // eslint-disable-next-line no-use-before-define\n    value = getMutableObject(value);\n  }\n\n  DEFINE_PROPERTY(targetObject, property, {\n    configurable: true,\n    enumerable: descriptor.enumerable || true,\n    value: value,\n    writable: true\n  });\n};\n\n/**\n * Returns mutable version of object passed\n *\n * @param {*} object\n * @returns {*}\n */\nfunction getMutableObject(object) {\n  var isObjectArray = isArray(object);\n\n  if (!isObjectArray & !isObject(object)) {\n    return object;\n  }\n\n  var mutableObject = isObjectArray ? [] : {};\n\n  if (isObjectArray) {\n    object.forEach(function (item, itemIndex) {\n      setMutableProperty(object, itemIndex, mutableObject);\n    });\n  } else {\n    forEachObject(object, function (value, property) {\n      setMutableProperty(object, property, mutableObject);\n    });\n  }\n\n  return mutableObject;\n}\n\n/**\n * Serialize object into string value, to be used for hashing\n *\n * @param {*} object\n * @returns {string}\n */\nvar serialize = exports.serialize = function serialize(object, Singulum) {\n  if (isInstanceOf(object, Singulum)) {\n    object = object.store;\n  }\n\n  var type = typeof object === 'undefined' ? 'undefined' : _typeof(object);\n\n  var serializedCode = '';\n\n  if (type === 'object') {\n    for (var element in object) {\n      serializedCode += '{' + type + ':' + element + serialize(object[element], Singulum) + '}';\n    }\n  } else if (type === 'function') {\n    serializedCode += '{' + type + ':' + object.toString() + '}';\n  } else {\n    serializedCode += '{' + type + ':' + object + '}';\n  }\n\n  return serializedCode.replace(/\\s/g, '');\n};\n\n/**\n * Build integer hashCode from object\n *\n * @param {*} object\n * @returns {number}\n */\nvar hashCode = exports.hashCode = function hashCode(object, Singulum) {\n  var serializedObject = serialize(object, Singulum);\n\n  if (serializedObject === '') {\n    return 0;\n  }\n\n  var hashCode = 0,\n      char = void 0;\n\n  for (var index = 0, length = serializedObject.length; index < length; index++) {\n    char = serializedObject.charCodeAt(index);\n    hashCode = (hashCode << 5) - hashCode + char;\n    hashCode |= 0;\n  }\n\n  return hashCode;\n};\n\n/**\n * Determines if the two objects have equal values (checks deeply)\n *\n * @param {*} object1\n * @param {*} object2\n * @returns {*}\n */\nvar isEqual = exports.isEqual = function isEqual(object1, object2, Singulum) {\n  return hashCode(object1, Singulum) === hashCode(object2, Singulum);\n};\n\n/**\n * Set property to be non-enumerable\n *\n * @param {Object} object\n * @param {string} property\n * @param {*} value\n */\nvar setHidden = exports.setHidden = function setHidden(object, property, value) {\n  DEFINE_PROPERTY(object, property, {\n    configurable: true,\n    enumerable: false,\n    value: value,\n    writable: true\n  });\n};\n\n/**\n * Creates deeply-immutable version of object by only creating getters on clone\n *\n * @param {*} object\n * @param {string} property\n * @param {*} value\n * @param {object} descriptor\n * @returns {*}\n */\nvar setImmutable = exports.setImmutable = function setImmutable(object, property, value) {\n  var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var realValue = void 0;\n\n  switch (true) {\n    case isArray(value):\n      realValue = [];\n\n      value.forEach(function (valueItem, valueItemIndex) {\n        setImmutable(realValue, valueItemIndex, valueItem);\n      });\n\n      break;\n\n    case isObject(value):\n      realValue = {};\n\n      GET_OWN_PROPERTY_NAMES(value).forEach(function (valueItemKey) {\n        setImmutable(realValue, valueItemKey, value[valueItemKey]);\n      });\n\n      break;\n\n    case isDate(value):\n      realValue = value.valueOf();\n      break;\n\n    case isFunction(value):\n      realValue = function realValue() {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        return value.apply(this, args);\n      };\n\n      forEachObject(value, function (item, key) {\n        if (value.hasOwnProperty(key)) {\n          setImmutable(realValue, key, item);\n        }\n      });\n\n      break;\n\n    default:\n      realValue = value;\n      break;\n  }\n\n  DEFINE_PROPERTY(object, property, {\n    configurable: false,\n    enumerable: descriptor.enumerable || true,\n    get: function get() {\n      return realValue;\n    },\n    set: function set() {\n      throw new SyntaxError('You are trying to set a value on an immutable object which is not allowed. Check the assignment of property ' + property + '.');\n    }\n  });\n\n  return object[property];\n};\n\n/**\n * Consolidated error throwing function, mainly for minification benefits\n *\n * @param {string} error\n */\nvar throwError = exports.throwError = function throwError(error) {\n  throw new Error(error);\n};\n\n/**\n * Set property on object as getter only, making it immutable\n *\n * @param {Object} object\n * @param {string} property\n * @param {*} value\n */\nvar setReadonly = exports.setReadonly = function setReadonly(object, property, value) {\n  DEFINE_PROPERTY(object, property, {\n    get: function get() {\n      return value;\n    },\n    set: function set() {\n      throwError('Cannot set a value for ' + property + ', as it is immutable.');\n    }\n  });\n};\n\nexports.default = {\n  bindFunction: bindFunction,\n  findIndex: findIndex,\n  forEachObject: forEachObject,\n  getClone: getClone,\n  getMutableObject: getMutableObject,\n  hashCode: hashCode,\n  isArray: isArray,\n  isClassInstance: isClassInstance,\n  isDate: isDate,\n  isEqual: isEqual,\n  isFunction: isFunction,\n  isInstanceOf: isInstanceOf,\n  isObject: isObject,\n  isProduction: isProduction,\n  isString: isString,\n  isUndefined: isUndefined,\n  setHidden: setHidden,\n  setImmutable: setImmutable,\n  setReadonly: setReadonly,\n  throwError: throwError\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaW5ndWx1bS9zcmMvdXRpbHMuanM/YTMwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBERUZJTkVfUFJPUEVSVFkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5jb25zdCBHRVRfT1dOX1BST1BFUlRZX05BTUVTID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG5jb25zdCBUT19TVFJJTkcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgb2JqZWN0IGlzIG9mIHR5cGUgQXJyYXlcbiAqXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc0FycmF5ID0gKG9iamVjdCkgPT4gVE9fU1RSSU5HLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIG9iamVjdCBpcyBvZiB0eXBlIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKG9iamVjdCkgPT4gVE9fU1RSSU5HLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgISFvYmplY3Q7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgYSBjbGFzc1xuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzQ2xhc3NJbnN0YW5jZSA9IChvYmplY3QpID0+XG4gIGlzT2JqZWN0KG9iamVjdCkgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCkuY29uc3RydWN0b3IgIT09IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3I7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBvYmplY3QgaXMgb2YgdHlwZSBEYXRlXG4gKiBOb3QgZXhwb3J0ZWQgYmVjYXVzZSBub3QgdXNlZCBlbHNld2hlcmVcbiAqXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc0RhdGUgPSAob2JqZWN0KSA9PiBUT19TVFJJTkcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBEYXRlXSc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBvYmplY3QgaXMgb2YgdHlwZSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSAob2JqZWN0KSA9PiBUT19TVFJJTkcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8IHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbic7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIG9iamVjdCBpcyBpbnN0YW5jZSBvZiBDb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb25zdHJ1Y3RvclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc0luc3RhbmNlT2YgPSAob2JqZWN0LCBDb25zdHJ1Y3RvcikgPT4gb2JqZWN0IGluc3RhbmNlb2YgQ29uc3RydWN0b3I7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB3ZSBhcmUgaW4gcHJvZHVjdGlvbiBvciBub3QsIGJhc2VkIG9uIE5PREVfRU5WXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1Byb2R1Y3Rpb24gPSAoKSA9PiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgb2JqZWN0IGlzIG9mIHR5cGUgU3RyaW5nXG4gKlxuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaXNTdHJpbmcgPSAob2JqZWN0KSA9PiBUT19TVFJJTkcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBTdHJpbmddJztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIG9iamVjdCBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1VuZGVmaW5lZCA9IChvYmplY3QpID0+IG9iamVjdCA9PT0gdm9pZCAwO1xuXG4vKipcbiAqIEJpbmRzIGZ1bmN0aW9uIHRvIHRoaXNBcmdcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmdcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGJpbmRGdW5jdGlvbiA9IChmbiwgdGhpc0FyZykgPT5cbiAgZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgaW5kZXggaW4gdGhlIGFycmF5IHdoZXJlIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgZmluZEluZGV4ID0gKGFycmF5LCBjYWxsYmFjaykgPT4ge1xuICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBpZiAoY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBQcm92aWRlZCBhcyBmYXN0ZXIgYWx0ZXJuYXRpdmUgZm9yIG5hdGl2ZSAuZm9yRWFjaFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JFYWNoT2JqZWN0ID0gKG9iamVjdCwgZm4pID0+IHtcbiAgY29uc3Qga2V5c0FycmF5ID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXNBcnJheS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c0FycmF5W2luZGV4XTtcblxuICAgIGZuKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBjbG9uZSBvZiBTaW5ndWx1bSBvYmplY3Qgd2l0aCBtZXRhZGF0YSBzdHJpcHBlZCBhbmQgY2hpbGRcbiAqIHN0b3JlcyB3aXRoIFNpbmd1bHVtU3RvcmUgY2xhc3MgYXBwbGllZFxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcGFyYW0ge1Npbmd1bHVtU3RvcmV9IFNpbmd1bHVtU3RvcmVcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnQgY29uc3QgZ2V0Q2xvbmUgPSAob2JqZWN0LCBTaW5ndWx1bVN0b3JlKSA9PiB7XG4gIGlmIChpc0FycmF5KG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0Lm1hcCgoaXRlbSkgPT4gZ2V0Q2xvbmUoaXRlbSwgU2luZ3VsdW1TdG9yZSkpO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICBsZXQgY2xvbmVPYmplY3QgPSB7fTtcblxuICAgIGZvckVhY2hPYmplY3Qob2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgY2xvbmVPYmplY3Rba2V5XSA9IGdldENsb25lKHZhbHVlLCBTaW5ndWx1bVN0b3JlKTtcbiAgICB9KTtcblxuICAgIGlmIChpc0luc3RhbmNlT2Yob2JqZWN0LCBTaW5ndWx1bVN0b3JlKSkge1xuICAgICAgY2xvbmVPYmplY3QgPSBuZXcgU2luZ3VsdW1TdG9yZShjbG9uZU9iamVjdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lT2JqZWN0O1xuICB9XG5cbiAgaWYgKGlzRGF0ZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdC52YWx1ZU9mKCkpO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmNvbnN0IHNldE11dGFibGVQcm9wZXJ0eSA9IChvYmplY3QsIHByb3BlcnR5LCB0YXJnZXRPYmplY3QpID0+IHtcbiAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSkgfHwge307XG5cbiAgbGV0IHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcblxuICBpZiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgdmFsdWUgPSBnZXRNdXRhYmxlT2JqZWN0KHZhbHVlKTtcbiAgfVxuXG4gIERFRklORV9QUk9QRVJUWSh0YXJnZXRPYmplY3QsIHByb3BlcnR5LCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCB0cnVlLFxuICAgIHZhbHVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBtdXRhYmxlIHZlcnNpb24gb2Ygb2JqZWN0IHBhc3NlZFxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE11dGFibGVPYmplY3Qob2JqZWN0KSB7XG4gIGNvbnN0IGlzT2JqZWN0QXJyYXkgPSBpc0FycmF5KG9iamVjdCk7XG5cbiAgaWYgKCFpc09iamVjdEFycmF5ICYgIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgbGV0IG11dGFibGVPYmplY3QgPSBpc09iamVjdEFycmF5ID8gW10gOiB7fTtcblxuICBpZiAoaXNPYmplY3RBcnJheSkge1xuICAgIG9iamVjdC5mb3JFYWNoKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICAgIHNldE11dGFibGVQcm9wZXJ0eShvYmplY3QsIGl0ZW1JbmRleCwgbXV0YWJsZU9iamVjdCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yRWFjaE9iamVjdChvYmplY3QsICh2YWx1ZSwgcHJvcGVydHkpID0+IHtcbiAgICAgIHNldE11dGFibGVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBtdXRhYmxlT2JqZWN0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBtdXRhYmxlT2JqZWN0O1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBvYmplY3QgaW50byBzdHJpbmcgdmFsdWUsIHRvIGJlIHVzZWQgZm9yIGhhc2hpbmdcbiAqXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHNlcmlhbGl6ZSA9IChvYmplY3QsIFNpbmd1bHVtKSA9PiB7XG4gIGlmIChpc0luc3RhbmNlT2Yob2JqZWN0LCBTaW5ndWx1bSkpIHtcbiAgICBvYmplY3QgPSBvYmplY3Quc3RvcmU7XG4gIH1cblxuICBjb25zdCB0eXBlID0gdHlwZW9mIG9iamVjdDtcblxuICBsZXQgc2VyaWFsaXplZENvZGUgPSAnJztcblxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGxldCBlbGVtZW50IGluIG9iamVjdCkge1xuICAgICAgc2VyaWFsaXplZENvZGUgKz0gYHske3R5cGV9OiR7ZWxlbWVudH0ke3NlcmlhbGl6ZShvYmplY3RbZWxlbWVudF0sIFNpbmd1bHVtKX19YDtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNlcmlhbGl6ZWRDb2RlICs9IGB7JHt0eXBlfToke29iamVjdC50b1N0cmluZygpfX1gO1xuICB9IGVsc2Uge1xuICAgIHNlcmlhbGl6ZWRDb2RlICs9IGB7JHt0eXBlfToke29iamVjdH19YDtcbiAgfVxuXG4gIHJldHVybiBzZXJpYWxpemVkQ29kZS5yZXBsYWNlKC9cXHMvZywgJycpO1xufTtcblxuLyoqXG4gKiBCdWlsZCBpbnRlZ2VyIGhhc2hDb2RlIGZyb20gb2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBoYXNoQ29kZSA9IChvYmplY3QsIFNpbmd1bHVtKSA9PiB7XG4gIGNvbnN0IHNlcmlhbGl6ZWRPYmplY3QgPSBzZXJpYWxpemUob2JqZWN0LCBTaW5ndWx1bSk7XG5cbiAgaWYgKHNlcmlhbGl6ZWRPYmplY3QgPT09ICcnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBsZXQgaGFzaENvZGUgPSAwLFxuICAgICAgY2hhcjtcblxuICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IHNlcmlhbGl6ZWRPYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNoYXIgPSBzZXJpYWxpemVkT2JqZWN0LmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIGhhc2hDb2RlID0gKGhhc2hDb2RlIDw8IDUpIC0gaGFzaENvZGUgKyBjaGFyO1xuICAgIGhhc2hDb2RlIHw9IDA7XG4gIH1cblxuICByZXR1cm4gaGFzaENvZGU7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHR3byBvYmplY3RzIGhhdmUgZXF1YWwgdmFsdWVzIChjaGVja3MgZGVlcGx5KVxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0MVxuICogQHBhcmFtIHsqfSBvYmplY3QyXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzRXF1YWwgPSAob2JqZWN0MSwgb2JqZWN0MiwgU2luZ3VsdW0pID0+IGhhc2hDb2RlKG9iamVjdDEsIFNpbmd1bHVtKSA9PT0gaGFzaENvZGUob2JqZWN0MiwgU2luZ3VsdW0pO1xuXG4vKipcbiAqIFNldCBwcm9wZXJ0eSB0byBiZSBub24tZW51bWVyYWJsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5leHBvcnQgY29uc3Qgc2V0SGlkZGVuID0gKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKSA9PiB7XG4gIERFRklORV9QUk9QRVJUWShvYmplY3QsIHByb3BlcnR5LCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBkZWVwbHktaW1tdXRhYmxlIHZlcnNpb24gb2Ygb2JqZWN0IGJ5IG9ubHkgY3JlYXRpbmcgZ2V0dGVycyBvbiBjbG9uZVxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7b2JqZWN0fSBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0IGNvbnN0IHNldEltbXV0YWJsZSA9IChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgZGVzY3JpcHRvciA9IHt9KSA9PiB7XG4gIGxldCByZWFsVmFsdWU7XG5cbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc0FycmF5KHZhbHVlKTpcbiAgICAgIHJlYWxWYWx1ZSA9IFtdO1xuXG4gICAgICB2YWx1ZS5mb3JFYWNoKCh2YWx1ZUl0ZW0sIHZhbHVlSXRlbUluZGV4KSA9PiB7XG4gICAgICAgIHNldEltbXV0YWJsZShyZWFsVmFsdWUsIHZhbHVlSXRlbUluZGV4LCB2YWx1ZUl0ZW0pO1xuICAgICAgfSk7XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBpc09iamVjdCh2YWx1ZSk6XG4gICAgICByZWFsVmFsdWUgPSB7fTtcblxuICAgICAgR0VUX09XTl9QUk9QRVJUWV9OQU1FUyh2YWx1ZSkuZm9yRWFjaCgodmFsdWVJdGVtS2V5KSA9PiB7XG4gICAgICAgIHNldEltbXV0YWJsZShyZWFsVmFsdWUsIHZhbHVlSXRlbUtleSwgdmFsdWVbdmFsdWVJdGVtS2V5XSk7XG4gICAgICB9KTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGlzRGF0ZSh2YWx1ZSk6XG4gICAgICByZWFsVmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgaXNGdW5jdGlvbih2YWx1ZSk6XG4gICAgICByZWFsVmFsdWUgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH07XG5cbiAgICAgIGZvckVhY2hPYmplY3QodmFsdWUsIChpdGVtLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBzZXRJbW11dGFibGUocmVhbFZhbHVlLCBrZXksIGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmVhbFZhbHVlID0gdmFsdWU7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIERFRklORV9QUk9QRVJUWShvYmplY3QsIHByb3BlcnR5LCB7XG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gcmVhbFZhbHVlO1xuICAgIH0sXG4gICAgc2V0KCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICBgWW91IGFyZSB0cnlpbmcgdG8gc2V0IGEgdmFsdWUgb24gYW4gaW1tdXRhYmxlIG9iamVjdCB3aGljaCBpcyBub3QgYWxsb3dlZC4gQ2hlY2sgdGhlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgJHtwcm9wZXJ0eX0uYFxuICAgICAgKTtcbiAgICB9LFxuICB9KTtcblxuICByZXR1cm4gb2JqZWN0W3Byb3BlcnR5XTtcbn07XG5cbi8qKlxuICogQ29uc29saWRhdGVkIGVycm9yIHRocm93aW5nIGZ1bmN0aW9uLCBtYWlubHkgZm9yIG1pbmlmaWNhdGlvbiBiZW5lZml0c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlcnJvclxuICovXG5leHBvcnQgY29uc3QgdGhyb3dFcnJvciA9IChlcnJvcikgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xufTtcblxuLyoqXG4gKiBTZXQgcHJvcGVydHkgb24gb2JqZWN0IGFzIGdldHRlciBvbmx5LCBtYWtpbmcgaXQgaW1tdXRhYmxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRSZWFkb25seSA9IChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICBERUZJTkVfUFJPUEVSVFkob2JqZWN0LCBwcm9wZXJ0eSwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNldCgpIHtcbiAgICAgIHRocm93RXJyb3IoYENhbm5vdCBzZXQgYSB2YWx1ZSBmb3IgJHtwcm9wZXJ0eX0sIGFzIGl0IGlzIGltbXV0YWJsZS5gKTtcbiAgICB9LFxuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgYmluZEZ1bmN0aW9uLFxuICBmaW5kSW5kZXgsXG4gIGZvckVhY2hPYmplY3QsXG4gIGdldENsb25lLFxuICBnZXRNdXRhYmxlT2JqZWN0LFxuICBoYXNoQ29kZSxcbiAgaXNBcnJheSxcbiAgaXNDbGFzc0luc3RhbmNlLFxuICBpc0RhdGUsXG4gIGlzRXF1YWwsXG4gIGlzRnVuY3Rpb24sXG4gIGlzSW5zdGFuY2VPZixcbiAgaXNPYmplY3QsXG4gIGlzUHJvZHVjdGlvbixcbiAgaXNTdHJpbmcsXG4gIGlzVW5kZWZpbmVkLFxuICBzZXRIaWRkZW4sXG4gIHNldEltbXV0YWJsZSxcbiAgc2V0UmVhZG9ubHksXG4gIHRocm93RXJyb3IsXG59O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQXFMQTtBQXJMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFIQTtBQUNBO0FBSUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRDQTtBQUNBO0FBd0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQVZBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils.js\n");

/***/ }),

/***/ 0:
/*!*************************!*\
  !*** multi ./src/index ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /home/tquetano/git/singulum/src/index */"./src/index.js");


/***/ })

/******/ });
});